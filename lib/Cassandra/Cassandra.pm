#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
use 5.10.0;
use strict;
use warnings;
use Thrift::Exception;
use Thrift::MessageType;
use Thrift::Type;

use Cassandra::Types;


# HELPER FUNCTIONS AND STRUCTURES

package Cassandra::Cassandra_login_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_login_args->mk_accessors( qw( auth_request ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{auth_request} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{auth_request}) {
      $self->{auth_request} = $vals->{auth_request};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_login_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{auth_request} = Cassandra::AuthenticationRequest->new();
        $xfer += $self->{auth_request}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_login_args');
  if (defined $self->{auth_request}) {
    $xfer += $output->writeFieldBegin('auth_request', Thrift::TType::STRUCT, 1);
    $xfer += $self->{auth_request}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_login_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_login_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authnx} = undef;
  $self->{authzx} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authnx}) {
      $self->{authnx} = $vals->{authnx};
    }
    if (defined $vals->{authzx}) {
      $self->{authzx} = $vals->{authzx};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_login_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{authnx} = Cassandra::AuthenticationException->new();
        $xfer += $self->{authnx}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{authzx} = Cassandra::AuthorizationException->new();
        $xfer += $self->{authzx}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_login_result');
  if (defined $self->{authnx}) {
    $xfer += $output->writeFieldBegin('authnx', Thrift::TType::STRUCT, 1);
    $xfer += $self->{authnx}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{authzx}) {
    $xfer += $output->writeFieldBegin('authzx', Thrift::TType::STRUCT, 2);
    $xfer += $self->{authzx}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_set_keyspace_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_set_keyspace_args->mk_accessors( qw( keyspace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_set_keyspace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_set_keyspace_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_set_keyspace_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_set_keyspace_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_set_keyspace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_set_keyspace_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_args->mk_accessors( qw( key column_path consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_path} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_path}) {
      $self->{column_path} = $vals->{column_path};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{column_path} = Cassandra::ColumnPath->new();
        $xfer += $self->{column_path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_path}) {
    $xfer += $output->writeFieldBegin('column_path', Thrift::TType::STRUCT, 2);
    $xfer += $self->{column_path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Thrift::TType::I32, 3);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{nfe} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{nfe}) {
      $self->{nfe} = $vals->{nfe};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = Cassandra::ColumnOrSuperColumn->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{nfe} = Cassandra::NotFoundException->new();
        $xfer += $self->{nfe}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ue} = Cassandra::UnavailableException->new();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{te} = Cassandra::TimedOutException->new();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nfe}) {
    $xfer += $output->writeFieldBegin('nfe', Thrift::TType::STRUCT, 2);
    $xfer += $self->{nfe}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Thrift::TType::STRUCT, 3);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Thrift::TType::STRUCT, 4);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_slice_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_slice_args->mk_accessors( qw( key column_parent predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_slice_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{column_parent} = Cassandra::ColumnParent->new();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{predicate} = Cassandra::SlicePredicate->new();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_slice_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', Thrift::TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', Thrift::TType::STRUCT, 3);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Thrift::TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_slice_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_slice_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_slice_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size198 = 0;
          $self->{success} = [];
          my $_etype201 = 0;
          $xfer += $input->readListBegin(\$_etype201, \$_size198);
          for (my $_i202 = 0; $_i202 < $_size198; ++$_i202)
          {
            my $elem203 = undef;
            $elem203 = Cassandra::ColumnOrSuperColumn->new();
            $xfer += $elem203->read($input);
            push(@{$self->{success}},$elem203);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ue} = Cassandra::UnavailableException->new();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{te} = Cassandra::TimedOutException->new();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_slice_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter204 (@{$self->{success}}) 
        {
          $xfer += ${iter204}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Thrift::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_count_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_count_args->mk_accessors( qw( key column_parent predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_count_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{column_parent} = Cassandra::ColumnParent->new();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{predicate} = Cassandra::SlicePredicate->new();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_count_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', Thrift::TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', Thrift::TType::STRUCT, 3);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Thrift::TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_count_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_count_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_count_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ue} = Cassandra::UnavailableException->new();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{te} = Cassandra::TimedOutException->new();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_count_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Thrift::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_multiget_slice_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_multiget_slice_args->mk_accessors( qw( keys column_parent predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keys} = undef;
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keys}) {
      $self->{keys} = $vals->{keys};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_slice_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size205 = 0;
          $self->{keys} = [];
          my $_etype208 = 0;
          $xfer += $input->readListBegin(\$_etype208, \$_size205);
          for (my $_i209 = 0; $_i209 < $_size205; ++$_i209)
          {
            my $elem210 = undef;
            $xfer += $input->readString(\$elem210);
            push(@{$self->{keys}},$elem210);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{column_parent} = Cassandra::ColumnParent->new();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{predicate} = Cassandra::SlicePredicate->new();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_slice_args');
  if (defined $self->{keys}) {
    $xfer += $output->writeFieldBegin('keys', Thrift::TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{keys}}));
      {
        foreach my $iter211 (@{$self->{keys}}) 
        {
          $xfer += $output->writeString($iter211);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', Thrift::TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', Thrift::TType::STRUCT, 3);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Thrift::TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_multiget_slice_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_multiget_slice_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_slice_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size212 = 0;
          $self->{success} = {};
          my $_ktype213 = 0;
          my $_vtype214 = 0;
          $xfer += $input->readMapBegin(\$_ktype213, \$_vtype214, \$_size212);
          for (my $_i216 = 0; $_i216 < $_size212; ++$_i216)
          {
            my $key217 = '';
            my $val218 = [];
            $xfer += $input->readString(\$key217);
            {
              my $_size219 = 0;
              $val218 = [];
              my $_etype222 = 0;
              $xfer += $input->readListBegin(\$_etype222, \$_size219);
              for (my $_i223 = 0; $_i223 < $_size219; ++$_i223)
              {
                my $elem224 = undef;
                $elem224 = Cassandra::ColumnOrSuperColumn->new();
                $xfer += $elem224->read($input);
                push(@{$val218},$elem224);
              }
              $xfer += $input->readListEnd();
            }
            $self->{success}->{$key217} = $val218;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ue} = Cassandra::UnavailableException->new();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{te} = Cassandra::TimedOutException->new();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_slice_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::LIST, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter225,$viter226) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter225);
          {
            $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{${viter226}}));
            {
              foreach my $iter227 (@{${viter226}}) 
              {
                $xfer += ${iter227}->write($output);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Thrift::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_multiget_count_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_multiget_count_args->mk_accessors( qw( keys column_parent predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keys} = undef;
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keys}) {
      $self->{keys} = $vals->{keys};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_count_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size228 = 0;
          $self->{keys} = [];
          my $_etype231 = 0;
          $xfer += $input->readListBegin(\$_etype231, \$_size228);
          for (my $_i232 = 0; $_i232 < $_size228; ++$_i232)
          {
            my $elem233 = undef;
            $xfer += $input->readString(\$elem233);
            push(@{$self->{keys}},$elem233);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{column_parent} = Cassandra::ColumnParent->new();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{predicate} = Cassandra::SlicePredicate->new();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_count_args');
  if (defined $self->{keys}) {
    $xfer += $output->writeFieldBegin('keys', Thrift::TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{keys}}));
      {
        foreach my $iter234 (@{$self->{keys}}) 
        {
          $xfer += $output->writeString($iter234);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', Thrift::TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', Thrift::TType::STRUCT, 3);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Thrift::TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_multiget_count_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_multiget_count_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_count_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size235 = 0;
          $self->{success} = {};
          my $_ktype236 = 0;
          my $_vtype237 = 0;
          $xfer += $input->readMapBegin(\$_ktype236, \$_vtype237, \$_size235);
          for (my $_i239 = 0; $_i239 < $_size235; ++$_i239)
          {
            my $key240 = '';
            my $val241 = 0;
            $xfer += $input->readString(\$key240);
            $xfer += $input->readI32(\$val241);
            $self->{success}->{$key240} = $val241;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ue} = Cassandra::UnavailableException->new();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{te} = Cassandra::TimedOutException->new();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_count_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::I32, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter242,$viter243) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter242);
          $xfer += $output->writeI32($viter243);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Thrift::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_range_slices_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_range_slices_args->mk_accessors( qw( column_parent predicate range consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{range} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{range}) {
      $self->{range} = $vals->{range};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_range_slices_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{column_parent} = Cassandra::ColumnParent->new();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{predicate} = Cassandra::SlicePredicate->new();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{range} = Cassandra::KeyRange->new();
        $xfer += $self->{range}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_range_slices_args');
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', Thrift::TType::STRUCT, 1);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', Thrift::TType::STRUCT, 2);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{range}) {
    $xfer += $output->writeFieldBegin('range', Thrift::TType::STRUCT, 3);
    $xfer += $self->{range}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Thrift::TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_range_slices_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_range_slices_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_range_slices_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size244 = 0;
          $self->{success} = [];
          my $_etype247 = 0;
          $xfer += $input->readListBegin(\$_etype247, \$_size244);
          for (my $_i248 = 0; $_i248 < $_size244; ++$_i248)
          {
            my $elem249 = undef;
            $elem249 = Cassandra::KeySlice->new();
            $xfer += $elem249->read($input);
            push(@{$self->{success}},$elem249);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ue} = Cassandra::UnavailableException->new();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{te} = Cassandra::TimedOutException->new();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_range_slices_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter250 (@{$self->{success}}) 
        {
          $xfer += ${iter250}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Thrift::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_paged_slice_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_paged_slice_args->mk_accessors( qw( column_family range start_column consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_family} = undef;
  $self->{range} = undef;
  $self->{start_column} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_family}) {
      $self->{column_family} = $vals->{column_family};
    }
    if (defined $vals->{range}) {
      $self->{range} = $vals->{range};
    }
    if (defined $vals->{start_column}) {
      $self->{start_column} = $vals->{start_column};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_paged_slice_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{column_family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{range} = Cassandra::KeyRange->new();
        $xfer += $self->{range}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{start_column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_paged_slice_args');
  if (defined $self->{column_family}) {
    $xfer += $output->writeFieldBegin('column_family', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{column_family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{range}) {
    $xfer += $output->writeFieldBegin('range', Thrift::TType::STRUCT, 2);
    $xfer += $self->{range}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_column}) {
    $xfer += $output->writeFieldBegin('start_column', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{start_column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Thrift::TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_paged_slice_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_paged_slice_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_paged_slice_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size251 = 0;
          $self->{success} = [];
          my $_etype254 = 0;
          $xfer += $input->readListBegin(\$_etype254, \$_size251);
          for (my $_i255 = 0; $_i255 < $_size251; ++$_i255)
          {
            my $elem256 = undef;
            $elem256 = Cassandra::KeySlice->new();
            $xfer += $elem256->read($input);
            push(@{$self->{success}},$elem256);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ue} = Cassandra::UnavailableException->new();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{te} = Cassandra::TimedOutException->new();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_paged_slice_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter257 (@{$self->{success}}) 
        {
          $xfer += ${iter257}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Thrift::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_indexed_slices_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_indexed_slices_args->mk_accessors( qw( column_parent index_clause column_predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_parent} = undef;
  $self->{index_clause} = undef;
  $self->{column_predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{index_clause}) {
      $self->{index_clause} = $vals->{index_clause};
    }
    if (defined $vals->{column_predicate}) {
      $self->{column_predicate} = $vals->{column_predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_indexed_slices_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{column_parent} = Cassandra::ColumnParent->new();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{index_clause} = Cassandra::IndexClause->new();
        $xfer += $self->{index_clause}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{column_predicate} = Cassandra::SlicePredicate->new();
        $xfer += $self->{column_predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_indexed_slices_args');
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', Thrift::TType::STRUCT, 1);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{index_clause}) {
    $xfer += $output->writeFieldBegin('index_clause', Thrift::TType::STRUCT, 2);
    $xfer += $self->{index_clause}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_predicate}) {
    $xfer += $output->writeFieldBegin('column_predicate', Thrift::TType::STRUCT, 3);
    $xfer += $self->{column_predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Thrift::TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_indexed_slices_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_indexed_slices_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_indexed_slices_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size258 = 0;
          $self->{success} = [];
          my $_etype261 = 0;
          $xfer += $input->readListBegin(\$_etype261, \$_size258);
          for (my $_i262 = 0; $_i262 < $_size258; ++$_i262)
          {
            my $elem263 = undef;
            $elem263 = Cassandra::KeySlice->new();
            $xfer += $elem263->read($input);
            push(@{$self->{success}},$elem263);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ue} = Cassandra::UnavailableException->new();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{te} = Cassandra::TimedOutException->new();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_indexed_slices_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter264 (@{$self->{success}}) 
        {
          $xfer += ${iter264}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Thrift::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_insert_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_insert_args->mk_accessors( qw( key column_parent column consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_parent} = undef;
  $self->{column} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_insert_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{column_parent} = Cassandra::ColumnParent->new();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{column} = Cassandra::Column->new();
        $xfer += $self->{column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_insert_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', Thrift::TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', Thrift::TType::STRUCT, 3);
    $xfer += $self->{column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Thrift::TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_insert_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_insert_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_insert_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ue} = Cassandra::UnavailableException->new();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{te} = Cassandra::TimedOutException->new();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_insert_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Thrift::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_add_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_add_args->mk_accessors( qw( key column_parent column consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_parent} = undef;
  $self->{column} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_add_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{column_parent} = Cassandra::ColumnParent->new();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{column} = Cassandra::CounterColumn->new();
        $xfer += $self->{column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_add_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', Thrift::TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', Thrift::TType::STRUCT, 3);
    $xfer += $self->{column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Thrift::TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_add_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_add_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_add_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ue} = Cassandra::UnavailableException->new();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{te} = Cassandra::TimedOutException->new();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_add_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Thrift::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_cas_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_cas_args->mk_accessors( qw( key column_family expected updates serial_consistency_level commit_consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_family} = undef;
  $self->{expected} = undef;
  $self->{updates} = undef;
  $self->{serial_consistency_level} = 9;
  $self->{commit_consistency_level} = 2;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_family}) {
      $self->{column_family} = $vals->{column_family};
    }
    if (defined $vals->{expected}) {
      $self->{expected} = $vals->{expected};
    }
    if (defined $vals->{updates}) {
      $self->{updates} = $vals->{updates};
    }
    if (defined $vals->{serial_consistency_level}) {
      $self->{serial_consistency_level} = $vals->{serial_consistency_level};
    }
    if (defined $vals->{commit_consistency_level}) {
      $self->{commit_consistency_level} = $vals->{commit_consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_cas_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{column_family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size265 = 0;
          $self->{expected} = [];
          my $_etype268 = 0;
          $xfer += $input->readListBegin(\$_etype268, \$_size265);
          for (my $_i269 = 0; $_i269 < $_size265; ++$_i269)
          {
            my $elem270 = undef;
            $elem270 = Cassandra::Column->new();
            $xfer += $elem270->read($input);
            push(@{$self->{expected}},$elem270);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size271 = 0;
          $self->{updates} = [];
          my $_etype274 = 0;
          $xfer += $input->readListBegin(\$_etype274, \$_size271);
          for (my $_i275 = 0; $_i275 < $_size271; ++$_i275)
          {
            my $elem276 = undef;
            $elem276 = Cassandra::Column->new();
            $xfer += $elem276->read($input);
            push(@{$self->{updates}},$elem276);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{serial_consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{commit_consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_cas_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_family}) {
    $xfer += $output->writeFieldBegin('column_family', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{column_family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{expected}) {
    $xfer += $output->writeFieldBegin('expected', Thrift::TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{expected}}));
      {
        foreach my $iter277 (@{$self->{expected}}) 
        {
          $xfer += ${iter277}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{updates}) {
    $xfer += $output->writeFieldBegin('updates', Thrift::TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{updates}}));
      {
        foreach my $iter278 (@{$self->{updates}}) 
        {
          $xfer += ${iter278}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{serial_consistency_level}) {
    $xfer += $output->writeFieldBegin('serial_consistency_level', Thrift::TType::I32, 5);
    $xfer += $output->writeI32($self->{serial_consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{commit_consistency_level}) {
    $xfer += $output->writeFieldBegin('commit_consistency_level', Thrift::TType::I32, 6);
    $xfer += $output->writeI32($self->{commit_consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_cas_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_cas_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_cas_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = Cassandra::CASResult->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ue} = Cassandra::UnavailableException->new();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{te} = Cassandra::TimedOutException->new();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_cas_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Thrift::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_remove_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_remove_args->mk_accessors( qw( key column_path timestamp consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_path} = undef;
  $self->{timestamp} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_path}) {
      $self->{column_path} = $vals->{column_path};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_remove_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{column_path} = Cassandra::ColumnPath->new();
        $xfer += $self->{column_path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_remove_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_path}) {
    $xfer += $output->writeFieldBegin('column_path', Thrift::TType::STRUCT, 2);
    $xfer += $self->{column_path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Thrift::TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_remove_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_remove_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_remove_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ue} = Cassandra::UnavailableException->new();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{te} = Cassandra::TimedOutException->new();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_remove_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Thrift::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_remove_counter_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_remove_counter_args->mk_accessors( qw( key path consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{path} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_remove_counter_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{path} = Cassandra::ColumnPath->new();
        $xfer += $self->{path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_remove_counter_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', Thrift::TType::STRUCT, 2);
    $xfer += $self->{path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Thrift::TType::I32, 3);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_remove_counter_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_remove_counter_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_remove_counter_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ue} = Cassandra::UnavailableException->new();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{te} = Cassandra::TimedOutException->new();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_remove_counter_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Thrift::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_batch_mutate_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_batch_mutate_args->mk_accessors( qw( mutation_map consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutation_map} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutation_map}) {
      $self->{mutation_map} = $vals->{mutation_map};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_batch_mutate_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size279 = 0;
          $self->{mutation_map} = {};
          my $_ktype280 = 0;
          my $_vtype281 = 0;
          $xfer += $input->readMapBegin(\$_ktype280, \$_vtype281, \$_size279);
          for (my $_i283 = 0; $_i283 < $_size279; ++$_i283)
          {
            my $key284 = '';
            my $val285 = [];
            $xfer += $input->readString(\$key284);
            {
              my $_size286 = 0;
              $val285 = {};
              my $_ktype287 = 0;
              my $_vtype288 = 0;
              $xfer += $input->readMapBegin(\$_ktype287, \$_vtype288, \$_size286);
              for (my $_i290 = 0; $_i290 < $_size286; ++$_i290)
              {
                my $key291 = '';
                my $val292 = [];
                $xfer += $input->readString(\$key291);
                {
                  my $_size293 = 0;
                  $val292 = [];
                  my $_etype296 = 0;
                  $xfer += $input->readListBegin(\$_etype296, \$_size293);
                  for (my $_i297 = 0; $_i297 < $_size293; ++$_i297)
                  {
                    my $elem298 = undef;
                    $elem298 = Cassandra::Mutation->new();
                    $xfer += $elem298->read($input);
                    push(@{$val292},$elem298);
                  }
                  $xfer += $input->readListEnd();
                }
                $val285->{$key291} = $val292;
              }
              $xfer += $input->readMapEnd();
            }
            $self->{mutation_map}->{$key284} = $val285;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_batch_mutate_args');
  if (defined $self->{mutation_map}) {
    $xfer += $output->writeFieldBegin('mutation_map', Thrift::TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::MAP, scalar(keys %{$self->{mutation_map}}));
      {
        while( my ($kiter299,$viter300) = each %{$self->{mutation_map}}) 
        {
          $xfer += $output->writeString($kiter299);
          {
            $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::LIST, scalar(keys %{${viter300}}));
            {
              while( my ($kiter301,$viter302) = each %{${viter300}}) 
              {
                $xfer += $output->writeString($kiter301);
                {
                  $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{${viter302}}));
                  {
                    foreach my $iter303 (@{${viter302}}) 
                    {
                      $xfer += ${iter303}->write($output);
                    }
                  }
                  $xfer += $output->writeListEnd();
                }
              }
            }
            $xfer += $output->writeMapEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Thrift::TType::I32, 2);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_batch_mutate_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_batch_mutate_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_batch_mutate_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ue} = Cassandra::UnavailableException->new();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{te} = Cassandra::TimedOutException->new();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_batch_mutate_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Thrift::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_atomic_batch_mutate_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_atomic_batch_mutate_args->mk_accessors( qw( mutation_map consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutation_map} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutation_map}) {
      $self->{mutation_map} = $vals->{mutation_map};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_atomic_batch_mutate_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size304 = 0;
          $self->{mutation_map} = {};
          my $_ktype305 = 0;
          my $_vtype306 = 0;
          $xfer += $input->readMapBegin(\$_ktype305, \$_vtype306, \$_size304);
          for (my $_i308 = 0; $_i308 < $_size304; ++$_i308)
          {
            my $key309 = '';
            my $val310 = [];
            $xfer += $input->readString(\$key309);
            {
              my $_size311 = 0;
              $val310 = {};
              my $_ktype312 = 0;
              my $_vtype313 = 0;
              $xfer += $input->readMapBegin(\$_ktype312, \$_vtype313, \$_size311);
              for (my $_i315 = 0; $_i315 < $_size311; ++$_i315)
              {
                my $key316 = '';
                my $val317 = [];
                $xfer += $input->readString(\$key316);
                {
                  my $_size318 = 0;
                  $val317 = [];
                  my $_etype321 = 0;
                  $xfer += $input->readListBegin(\$_etype321, \$_size318);
                  for (my $_i322 = 0; $_i322 < $_size318; ++$_i322)
                  {
                    my $elem323 = undef;
                    $elem323 = Cassandra::Mutation->new();
                    $xfer += $elem323->read($input);
                    push(@{$val317},$elem323);
                  }
                  $xfer += $input->readListEnd();
                }
                $val310->{$key316} = $val317;
              }
              $xfer += $input->readMapEnd();
            }
            $self->{mutation_map}->{$key309} = $val310;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_atomic_batch_mutate_args');
  if (defined $self->{mutation_map}) {
    $xfer += $output->writeFieldBegin('mutation_map', Thrift::TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::MAP, scalar(keys %{$self->{mutation_map}}));
      {
        while( my ($kiter324,$viter325) = each %{$self->{mutation_map}}) 
        {
          $xfer += $output->writeString($kiter324);
          {
            $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::LIST, scalar(keys %{${viter325}}));
            {
              while( my ($kiter326,$viter327) = each %{${viter325}}) 
              {
                $xfer += $output->writeString($kiter326);
                {
                  $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{${viter327}}));
                  {
                    foreach my $iter328 (@{${viter327}}) 
                    {
                      $xfer += ${iter328}->write($output);
                    }
                  }
                  $xfer += $output->writeListEnd();
                }
              }
            }
            $xfer += $output->writeMapEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Thrift::TType::I32, 2);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_atomic_batch_mutate_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_atomic_batch_mutate_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_atomic_batch_mutate_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ue} = Cassandra::UnavailableException->new();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{te} = Cassandra::TimedOutException->new();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_atomic_batch_mutate_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Thrift::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_truncate_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_truncate_args->mk_accessors( qw( cfname ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cfname} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cfname}) {
      $self->{cfname} = $vals->{cfname};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_truncate_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{cfname});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_truncate_args');
  if (defined $self->{cfname}) {
    $xfer += $output->writeFieldBegin('cfname', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{cfname});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_truncate_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_truncate_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_truncate_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ue} = Cassandra::UnavailableException->new();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{te} = Cassandra::TimedOutException->new();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_truncate_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Thrift::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_multi_slice_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_multi_slice_args->mk_accessors( qw( request ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{request} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{request}) {
      $self->{request} = $vals->{request};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_multi_slice_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{request} = Cassandra::MultiSliceRequest->new();
        $xfer += $self->{request}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_multi_slice_args');
  if (defined $self->{request}) {
    $xfer += $output->writeFieldBegin('request', Thrift::TType::STRUCT, 1);
    $xfer += $self->{request}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_multi_slice_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_multi_slice_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_multi_slice_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size329 = 0;
          $self->{success} = [];
          my $_etype332 = 0;
          $xfer += $input->readListBegin(\$_etype332, \$_size329);
          for (my $_i333 = 0; $_i333 < $_size329; ++$_i333)
          {
            my $elem334 = undef;
            $elem334 = Cassandra::ColumnOrSuperColumn->new();
            $xfer += $elem334->read($input);
            push(@{$self->{success}},$elem334);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ue} = Cassandra::UnavailableException->new();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{te} = Cassandra::TimedOutException->new();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_multi_slice_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter335 (@{$self->{success}}) 
        {
          $xfer += ${iter335}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Thrift::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_schema_versions_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_schema_versions_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_schema_versions_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_schema_versions_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_schema_versions_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_schema_versions_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size336 = 0;
          $self->{success} = {};
          my $_ktype337 = 0;
          my $_vtype338 = 0;
          $xfer += $input->readMapBegin(\$_ktype337, \$_vtype338, \$_size336);
          for (my $_i340 = 0; $_i340 < $_size336; ++$_i340)
          {
            my $key341 = '';
            my $val342 = [];
            $xfer += $input->readString(\$key341);
            {
              my $_size343 = 0;
              $val342 = [];
              my $_etype346 = 0;
              $xfer += $input->readListBegin(\$_etype346, \$_size343);
              for (my $_i347 = 0; $_i347 < $_size343; ++$_i347)
              {
                my $elem348 = undef;
                $xfer += $input->readString(\$elem348);
                push(@{$val342},$elem348);
              }
              $xfer += $input->readListEnd();
            }
            $self->{success}->{$key341} = $val342;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_schema_versions_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::LIST, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter349,$viter350) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter349);
          {
            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{${viter350}}));
            {
              foreach my $iter351 (@{${viter350}}) 
              {
                $xfer += $output->writeString($iter351);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_keyspaces_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_keyspaces_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_keyspaces_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_keyspaces_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_keyspaces_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_keyspaces_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size352 = 0;
          $self->{success} = [];
          my $_etype355 = 0;
          $xfer += $input->readListBegin(\$_etype355, \$_size352);
          for (my $_i356 = 0; $_i356 < $_size352; ++$_i356)
          {
            my $elem357 = undef;
            $elem357 = Cassandra::KsDef->new();
            $xfer += $elem357->read($input);
            push(@{$self->{success}},$elem357);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_keyspaces_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter358 (@{$self->{success}}) 
        {
          $xfer += ${iter358}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_cluster_name_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_cluster_name_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_cluster_name_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_cluster_name_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_cluster_name_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_cluster_name_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_cluster_name_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_version_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_version_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_version_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_version_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_version_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_version_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_version_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_ring_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_ring_args->mk_accessors( qw( keyspace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_ring_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_ring_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_ring_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_ring_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_ring_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size359 = 0;
          $self->{success} = [];
          my $_etype362 = 0;
          $xfer += $input->readListBegin(\$_etype362, \$_size359);
          for (my $_i363 = 0; $_i363 < $_size359; ++$_i363)
          {
            my $elem364 = undef;
            $elem364 = Cassandra::TokenRange->new();
            $xfer += $elem364->read($input);
            push(@{$self->{success}},$elem364);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_ring_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter365 (@{$self->{success}}) 
        {
          $xfer += ${iter365}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_local_ring_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_local_ring_args->mk_accessors( qw( keyspace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_local_ring_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_local_ring_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_local_ring_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_local_ring_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_local_ring_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size366 = 0;
          $self->{success} = [];
          my $_etype369 = 0;
          $xfer += $input->readListBegin(\$_etype369, \$_size366);
          for (my $_i370 = 0; $_i370 < $_size366; ++$_i370)
          {
            my $elem371 = undef;
            $elem371 = Cassandra::TokenRange->new();
            $xfer += $elem371->read($input);
            push(@{$self->{success}},$elem371);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_local_ring_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter372 (@{$self->{success}}) 
        {
          $xfer += ${iter372}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_token_map_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_token_map_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_token_map_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_token_map_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_token_map_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_token_map_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size373 = 0;
          $self->{success} = {};
          my $_ktype374 = 0;
          my $_vtype375 = 0;
          $xfer += $input->readMapBegin(\$_ktype374, \$_vtype375, \$_size373);
          for (my $_i377 = 0; $_i377 < $_size373; ++$_i377)
          {
            my $key378 = '';
            my $val379 = '';
            $xfer += $input->readString(\$key378);
            $xfer += $input->readString(\$val379);
            $self->{success}->{$key378} = $val379;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_token_map_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter380,$viter381) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter380);
          $xfer += $output->writeString($viter381);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_partitioner_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_partitioner_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_partitioner_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_partitioner_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_partitioner_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_partitioner_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_partitioner_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_snitch_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_snitch_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_snitch_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_snitch_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_snitch_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_snitch_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_snitch_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_keyspace_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_keyspace_args->mk_accessors( qw( keyspace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_keyspace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_keyspace_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_keyspace_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_keyspace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{nfe} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{nfe}) {
      $self->{nfe} = $vals->{nfe};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_keyspace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = Cassandra::KsDef->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{nfe} = Cassandra::NotFoundException->new();
        $xfer += $self->{nfe}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_keyspace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nfe}) {
    $xfer += $output->writeFieldBegin('nfe', Thrift::TType::STRUCT, 1);
    $xfer += $self->{nfe}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_splits_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_splits_args->mk_accessors( qw( cfName start_token end_token keys_per_split ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cfName} = undef;
  $self->{start_token} = undef;
  $self->{end_token} = undef;
  $self->{keys_per_split} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cfName}) {
      $self->{cfName} = $vals->{cfName};
    }
    if (defined $vals->{start_token}) {
      $self->{start_token} = $vals->{start_token};
    }
    if (defined $vals->{end_token}) {
      $self->{end_token} = $vals->{end_token};
    }
    if (defined $vals->{keys_per_split}) {
      $self->{keys_per_split} = $vals->{keys_per_split};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_splits_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{cfName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{start_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{end_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{keys_per_split});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_splits_args');
  if (defined $self->{cfName}) {
    $xfer += $output->writeFieldBegin('cfName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{cfName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_token}) {
    $xfer += $output->writeFieldBegin('start_token', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{start_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_token}) {
    $xfer += $output->writeFieldBegin('end_token', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{end_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{keys_per_split}) {
    $xfer += $output->writeFieldBegin('keys_per_split', Thrift::TType::I32, 4);
    $xfer += $output->writeI32($self->{keys_per_split});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_splits_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_splits_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_splits_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size382 = 0;
          $self->{success} = [];
          my $_etype385 = 0;
          $xfer += $input->readListBegin(\$_etype385, \$_size382);
          for (my $_i386 = 0; $_i386 < $_size382; ++$_i386)
          {
            my $elem387 = undef;
            $xfer += $input->readString(\$elem387);
            push(@{$self->{success}},$elem387);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_splits_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter388 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter388);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_trace_next_query_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_trace_next_query_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_trace_next_query_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_trace_next_query_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_trace_next_query_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_trace_next_query_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_trace_next_query_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_splits_ex_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_splits_ex_args->mk_accessors( qw( cfName start_token end_token keys_per_split ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cfName} = undef;
  $self->{start_token} = undef;
  $self->{end_token} = undef;
  $self->{keys_per_split} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cfName}) {
      $self->{cfName} = $vals->{cfName};
    }
    if (defined $vals->{start_token}) {
      $self->{start_token} = $vals->{start_token};
    }
    if (defined $vals->{end_token}) {
      $self->{end_token} = $vals->{end_token};
    }
    if (defined $vals->{keys_per_split}) {
      $self->{keys_per_split} = $vals->{keys_per_split};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_splits_ex_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{cfName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{start_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{end_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{keys_per_split});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_splits_ex_args');
  if (defined $self->{cfName}) {
    $xfer += $output->writeFieldBegin('cfName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{cfName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_token}) {
    $xfer += $output->writeFieldBegin('start_token', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{start_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_token}) {
    $xfer += $output->writeFieldBegin('end_token', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{end_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{keys_per_split}) {
    $xfer += $output->writeFieldBegin('keys_per_split', Thrift::TType::I32, 4);
    $xfer += $output->writeI32($self->{keys_per_split});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_splits_ex_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_splits_ex_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_splits_ex_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size389 = 0;
          $self->{success} = [];
          my $_etype392 = 0;
          $xfer += $input->readListBegin(\$_etype392, \$_size389);
          for (my $_i393 = 0; $_i393 < $_size389; ++$_i393)
          {
            my $elem394 = undef;
            $elem394 = Cassandra::CfSplit->new();
            $xfer += $elem394->read($input);
            push(@{$self->{success}},$elem394);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_splits_ex_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter395 (@{$self->{success}}) 
        {
          $xfer += ${iter395}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_add_column_family_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_add_column_family_args->mk_accessors( qw( cf_def ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cf_def} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cf_def}) {
      $self->{cf_def} = $vals->{cf_def};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_add_column_family_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{cf_def} = Cassandra::CfDef->new();
        $xfer += $self->{cf_def}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_add_column_family_args');
  if (defined $self->{cf_def}) {
    $xfer += $output->writeFieldBegin('cf_def', Thrift::TType::STRUCT, 1);
    $xfer += $self->{cf_def}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_add_column_family_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_add_column_family_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_add_column_family_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{sde} = Cassandra::SchemaDisagreementException->new();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_add_column_family_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', Thrift::TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_drop_column_family_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_drop_column_family_args->mk_accessors( qw( column_family ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_family} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_family}) {
      $self->{column_family} = $vals->{column_family};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_drop_column_family_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{column_family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_drop_column_family_args');
  if (defined $self->{column_family}) {
    $xfer += $output->writeFieldBegin('column_family', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{column_family});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_drop_column_family_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_drop_column_family_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_drop_column_family_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{sde} = Cassandra::SchemaDisagreementException->new();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_drop_column_family_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', Thrift::TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_add_keyspace_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_add_keyspace_args->mk_accessors( qw( ks_def ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ks_def} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ks_def}) {
      $self->{ks_def} = $vals->{ks_def};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_add_keyspace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ks_def} = Cassandra::KsDef->new();
        $xfer += $self->{ks_def}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_add_keyspace_args');
  if (defined $self->{ks_def}) {
    $xfer += $output->writeFieldBegin('ks_def', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ks_def}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_add_keyspace_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_add_keyspace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_add_keyspace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{sde} = Cassandra::SchemaDisagreementException->new();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_add_keyspace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', Thrift::TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_drop_keyspace_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_drop_keyspace_args->mk_accessors( qw( keyspace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_drop_keyspace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_drop_keyspace_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_drop_keyspace_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_drop_keyspace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_drop_keyspace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{sde} = Cassandra::SchemaDisagreementException->new();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_drop_keyspace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', Thrift::TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_update_keyspace_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_update_keyspace_args->mk_accessors( qw( ks_def ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ks_def} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ks_def}) {
      $self->{ks_def} = $vals->{ks_def};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_update_keyspace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ks_def} = Cassandra::KsDef->new();
        $xfer += $self->{ks_def}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_update_keyspace_args');
  if (defined $self->{ks_def}) {
    $xfer += $output->writeFieldBegin('ks_def', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ks_def}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_update_keyspace_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_update_keyspace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_update_keyspace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{sde} = Cassandra::SchemaDisagreementException->new();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_update_keyspace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', Thrift::TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_update_column_family_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_update_column_family_args->mk_accessors( qw( cf_def ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cf_def} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cf_def}) {
      $self->{cf_def} = $vals->{cf_def};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_update_column_family_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{cf_def} = Cassandra::CfDef->new();
        $xfer += $self->{cf_def}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_update_column_family_args');
  if (defined $self->{cf_def}) {
    $xfer += $output->writeFieldBegin('cf_def', Thrift::TType::STRUCT, 1);
    $xfer += $self->{cf_def}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_update_column_family_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_update_column_family_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_update_column_family_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{sde} = Cassandra::SchemaDisagreementException->new();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_update_column_family_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', Thrift::TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_execute_cql_query_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_execute_cql_query_args->mk_accessors( qw( query compression ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{query} = undef;
  $self->{compression} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{compression}) {
      $self->{compression} = $vals->{compression};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_execute_cql_query_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{query});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{compression});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_execute_cql_query_args');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{query});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compression}) {
    $xfer += $output->writeFieldBegin('compression', Thrift::TType::I32, 2);
    $xfer += $output->writeI32($self->{compression});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_execute_cql_query_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_execute_cql_query_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_execute_cql_query_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = Cassandra::CqlResult->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ue} = Cassandra::UnavailableException->new();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{te} = Cassandra::TimedOutException->new();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{sde} = Cassandra::SchemaDisagreementException->new();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_execute_cql_query_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Thrift::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', Thrift::TType::STRUCT, 4);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_execute_cql3_query_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_execute_cql3_query_args->mk_accessors( qw( query compression consistency ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{query} = undef;
  $self->{compression} = undef;
  $self->{consistency} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{compression}) {
      $self->{compression} = $vals->{compression};
    }
    if (defined $vals->{consistency}) {
      $self->{consistency} = $vals->{consistency};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_execute_cql3_query_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{query});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{compression});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_execute_cql3_query_args');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{query});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compression}) {
    $xfer += $output->writeFieldBegin('compression', Thrift::TType::I32, 2);
    $xfer += $output->writeI32($self->{compression});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency}) {
    $xfer += $output->writeFieldBegin('consistency', Thrift::TType::I32, 3);
    $xfer += $output->writeI32($self->{consistency});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_execute_cql3_query_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_execute_cql3_query_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_execute_cql3_query_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = Cassandra::CqlResult->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ue} = Cassandra::UnavailableException->new();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{te} = Cassandra::TimedOutException->new();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{sde} = Cassandra::SchemaDisagreementException->new();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_execute_cql3_query_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Thrift::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', Thrift::TType::STRUCT, 4);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_prepare_cql_query_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_prepare_cql_query_args->mk_accessors( qw( query compression ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{query} = undef;
  $self->{compression} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{compression}) {
      $self->{compression} = $vals->{compression};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_prepare_cql_query_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{query});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{compression});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_prepare_cql_query_args');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{query});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compression}) {
    $xfer += $output->writeFieldBegin('compression', Thrift::TType::I32, 2);
    $xfer += $output->writeI32($self->{compression});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_prepare_cql_query_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_prepare_cql_query_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_prepare_cql_query_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = Cassandra::CqlPreparedResult->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_prepare_cql_query_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_prepare_cql3_query_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_prepare_cql3_query_args->mk_accessors( qw( query compression ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{query} = undef;
  $self->{compression} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{compression}) {
      $self->{compression} = $vals->{compression};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_prepare_cql3_query_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{query});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{compression});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_prepare_cql3_query_args');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{query});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compression}) {
    $xfer += $output->writeFieldBegin('compression', Thrift::TType::I32, 2);
    $xfer += $output->writeI32($self->{compression});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_prepare_cql3_query_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_prepare_cql3_query_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_prepare_cql3_query_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = Cassandra::CqlPreparedResult->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_prepare_cql3_query_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_execute_prepared_cql_query_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_execute_prepared_cql_query_args->mk_accessors( qw( itemId values ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{itemId} = undef;
  $self->{values} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{itemId}) {
      $self->{itemId} = $vals->{itemId};
    }
    if (defined $vals->{values}) {
      $self->{values} = $vals->{values};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_execute_prepared_cql_query_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{itemId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size396 = 0;
          $self->{values} = [];
          my $_etype399 = 0;
          $xfer += $input->readListBegin(\$_etype399, \$_size396);
          for (my $_i400 = 0; $_i400 < $_size396; ++$_i400)
          {
            my $elem401 = undef;
            $xfer += $input->readString(\$elem401);
            push(@{$self->{values}},$elem401);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_execute_prepared_cql_query_args');
  if (defined $self->{itemId}) {
    $xfer += $output->writeFieldBegin('itemId', Thrift::TType::I32, 1);
    $xfer += $output->writeI32($self->{itemId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{values}) {
    $xfer += $output->writeFieldBegin('values', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{values}}));
      {
        foreach my $iter402 (@{$self->{values}}) 
        {
          $xfer += $output->writeString($iter402);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_execute_prepared_cql_query_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_execute_prepared_cql_query_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_execute_prepared_cql_query_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = Cassandra::CqlResult->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ue} = Cassandra::UnavailableException->new();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{te} = Cassandra::TimedOutException->new();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{sde} = Cassandra::SchemaDisagreementException->new();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_execute_prepared_cql_query_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Thrift::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', Thrift::TType::STRUCT, 4);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_execute_prepared_cql3_query_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_execute_prepared_cql3_query_args->mk_accessors( qw( itemId values consistency ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{itemId} = undef;
  $self->{values} = undef;
  $self->{consistency} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{itemId}) {
      $self->{itemId} = $vals->{itemId};
    }
    if (defined $vals->{values}) {
      $self->{values} = $vals->{values};
    }
    if (defined $vals->{consistency}) {
      $self->{consistency} = $vals->{consistency};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_execute_prepared_cql3_query_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{itemId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size403 = 0;
          $self->{values} = [];
          my $_etype406 = 0;
          $xfer += $input->readListBegin(\$_etype406, \$_size403);
          for (my $_i407 = 0; $_i407 < $_size403; ++$_i407)
          {
            my $elem408 = undef;
            $xfer += $input->readString(\$elem408);
            push(@{$self->{values}},$elem408);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_execute_prepared_cql3_query_args');
  if (defined $self->{itemId}) {
    $xfer += $output->writeFieldBegin('itemId', Thrift::TType::I32, 1);
    $xfer += $output->writeI32($self->{itemId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{values}) {
    $xfer += $output->writeFieldBegin('values', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{values}}));
      {
        foreach my $iter409 (@{$self->{values}}) 
        {
          $xfer += $output->writeString($iter409);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency}) {
    $xfer += $output->writeFieldBegin('consistency', Thrift::TType::I32, 3);
    $xfer += $output->writeI32($self->{consistency});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_execute_prepared_cql3_query_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_execute_prepared_cql3_query_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_execute_prepared_cql3_query_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = Cassandra::CqlResult->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ue} = Cassandra::UnavailableException->new();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{te} = Cassandra::TimedOutException->new();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{sde} = Cassandra::SchemaDisagreementException->new();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_execute_prepared_cql3_query_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Thrift::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', Thrift::TType::STRUCT, 4);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_set_cql_version_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_set_cql_version_args->mk_accessors( qw( version ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{version} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{version}) {
      $self->{version} = $vals->{version};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_set_cql_version_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{version});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_set_cql_version_args');
  if (defined $self->{version}) {
    $xfer += $output->writeFieldBegin('version', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{version});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_set_cql_version_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_set_cql_version_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_set_cql_version_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ire} = Cassandra::InvalidRequestException->new();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_set_cql_version_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CassandraIf;

use strict;


sub login{
  my $self = shift;
  my $auth_request = shift;

  die 'implement interface';
}

sub set_keyspace{
  my $self = shift;
  my $keyspace = shift;

  die 'implement interface';
}

sub get{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_slice{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_count{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub multiget_slice{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub multiget_count{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_range_slices{
  my $self = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $range = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_paged_slice{
  my $self = shift;
  my $column_family = shift;
  my $range = shift;
  my $start_column = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_indexed_slices{
  my $self = shift;
  my $column_parent = shift;
  my $index_clause = shift;
  my $column_predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub insert{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub add{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub cas{
  my $self = shift;
  my $key = shift;
  my $column_family = shift;
  my $expected = shift;
  my $updates = shift;
  my $serial_consistency_level = shift;
  my $commit_consistency_level = shift;

  die 'implement interface';
}

sub remove{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub remove_counter{
  my $self = shift;
  my $key = shift;
  my $path = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub batch_mutate{
  my $self = shift;
  my $mutation_map = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub atomic_batch_mutate{
  my $self = shift;
  my $mutation_map = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub truncate{
  my $self = shift;
  my $cfname = shift;

  die 'implement interface';
}

sub get_multi_slice{
  my $self = shift;
  my $request = shift;

  die 'implement interface';
}

sub describe_schema_versions{
  my $self = shift;

  die 'implement interface';
}

sub describe_keyspaces{
  my $self = shift;

  die 'implement interface';
}

sub describe_cluster_name{
  my $self = shift;

  die 'implement interface';
}

sub describe_version{
  my $self = shift;

  die 'implement interface';
}

sub describe_ring{
  my $self = shift;
  my $keyspace = shift;

  die 'implement interface';
}

sub describe_local_ring{
  my $self = shift;
  my $keyspace = shift;

  die 'implement interface';
}

sub describe_token_map{
  my $self = shift;

  die 'implement interface';
}

sub describe_partitioner{
  my $self = shift;

  die 'implement interface';
}

sub describe_snitch{
  my $self = shift;

  die 'implement interface';
}

sub describe_keyspace{
  my $self = shift;
  my $keyspace = shift;

  die 'implement interface';
}

sub describe_splits{
  my $self = shift;
  my $cfName = shift;
  my $start_token = shift;
  my $end_token = shift;
  my $keys_per_split = shift;

  die 'implement interface';
}

sub trace_next_query{
  my $self = shift;

  die 'implement interface';
}

sub describe_splits_ex{
  my $self = shift;
  my $cfName = shift;
  my $start_token = shift;
  my $end_token = shift;
  my $keys_per_split = shift;

  die 'implement interface';
}

sub system_add_column_family{
  my $self = shift;
  my $cf_def = shift;

  die 'implement interface';
}

sub system_drop_column_family{
  my $self = shift;
  my $column_family = shift;

  die 'implement interface';
}

sub system_add_keyspace{
  my $self = shift;
  my $ks_def = shift;

  die 'implement interface';
}

sub system_drop_keyspace{
  my $self = shift;
  my $keyspace = shift;

  die 'implement interface';
}

sub system_update_keyspace{
  my $self = shift;
  my $ks_def = shift;

  die 'implement interface';
}

sub system_update_column_family{
  my $self = shift;
  my $cf_def = shift;

  die 'implement interface';
}

sub execute_cql_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

  die 'implement interface';
}

sub execute_cql3_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;
  my $consistency = shift;

  die 'implement interface';
}

sub prepare_cql_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

  die 'implement interface';
}

sub prepare_cql3_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

  die 'implement interface';
}

sub execute_prepared_cql_query{
  my $self = shift;
  my $itemId = shift;
  my $values = shift;

  die 'implement interface';
}

sub execute_prepared_cql3_query{
  my $self = shift;
  my $itemId = shift;
  my $values = shift;
  my $consistency = shift;

  die 'implement interface';
}

sub set_cql_version{
  my $self = shift;
  my $version = shift;

  die 'implement interface';
}

package Cassandra::CassandraRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub login{
  my ($self, $request) = @_;

  my $auth_request = ($request->{'auth_request'}) ? $request->{'auth_request'} : undef;
  return $self->{impl}->login($auth_request);
}

sub set_keyspace{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  return $self->{impl}->set_keyspace($keyspace);
}

sub get{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_path = ($request->{'column_path'}) ? $request->{'column_path'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get($key, $column_path, $consistency_level);
}

sub get_slice{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_slice($key, $column_parent, $predicate, $consistency_level);
}

sub get_count{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_count($key, $column_parent, $predicate, $consistency_level);
}

sub multiget_slice{
  my ($self, $request) = @_;

  my $keys = ($request->{'keys'}) ? $request->{'keys'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->multiget_slice($keys, $column_parent, $predicate, $consistency_level);
}

sub multiget_count{
  my ($self, $request) = @_;

  my $keys = ($request->{'keys'}) ? $request->{'keys'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->multiget_count($keys, $column_parent, $predicate, $consistency_level);
}

sub get_range_slices{
  my ($self, $request) = @_;

  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $range = ($request->{'range'}) ? $request->{'range'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_range_slices($column_parent, $predicate, $range, $consistency_level);
}

sub get_paged_slice{
  my ($self, $request) = @_;

  my $column_family = ($request->{'column_family'}) ? $request->{'column_family'} : undef;
  my $range = ($request->{'range'}) ? $request->{'range'} : undef;
  my $start_column = ($request->{'start_column'}) ? $request->{'start_column'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_paged_slice($column_family, $range, $start_column, $consistency_level);
}

sub get_indexed_slices{
  my ($self, $request) = @_;

  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $index_clause = ($request->{'index_clause'}) ? $request->{'index_clause'} : undef;
  my $column_predicate = ($request->{'column_predicate'}) ? $request->{'column_predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_indexed_slices($column_parent, $index_clause, $column_predicate, $consistency_level);
}

sub insert{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->insert($key, $column_parent, $column, $consistency_level);
}

sub add{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->add($key, $column_parent, $column, $consistency_level);
}

sub cas{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_family = ($request->{'column_family'}) ? $request->{'column_family'} : undef;
  my $expected = ($request->{'expected'}) ? $request->{'expected'} : undef;
  my $updates = ($request->{'updates'}) ? $request->{'updates'} : undef;
  my $serial_consistency_level = ($request->{'serial_consistency_level'}) ? $request->{'serial_consistency_level'} : undef;
  my $commit_consistency_level = ($request->{'commit_consistency_level'}) ? $request->{'commit_consistency_level'} : undef;
  return $self->{impl}->cas($key, $column_family, $expected, $updates, $serial_consistency_level, $commit_consistency_level);
}

sub remove{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_path = ($request->{'column_path'}) ? $request->{'column_path'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->remove($key, $column_path, $timestamp, $consistency_level);
}

sub remove_counter{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->remove_counter($key, $path, $consistency_level);
}

sub batch_mutate{
  my ($self, $request) = @_;

  my $mutation_map = ($request->{'mutation_map'}) ? $request->{'mutation_map'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->batch_mutate($mutation_map, $consistency_level);
}

sub atomic_batch_mutate{
  my ($self, $request) = @_;

  my $mutation_map = ($request->{'mutation_map'}) ? $request->{'mutation_map'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->atomic_batch_mutate($mutation_map, $consistency_level);
}

sub truncate{
  my ($self, $request) = @_;

  my $cfname = ($request->{'cfname'}) ? $request->{'cfname'} : undef;
  return $self->{impl}->truncate($cfname);
}

sub get_multi_slice{
  my ($self, $request) = @_;

  my $req = ($request->{'request'}) ? $request->{'request'} : undef;
  return $self->{impl}->get_multi_slice($req);
}

sub describe_schema_versions{
  my ($self, $request) = @_;

  return $self->{impl}->describe_schema_versions();
}

sub describe_keyspaces{
  my ($self, $request) = @_;

  return $self->{impl}->describe_keyspaces();
}

sub describe_cluster_name{
  my ($self, $request) = @_;

  return $self->{impl}->describe_cluster_name();
}

sub describe_version{
  my ($self, $request) = @_;

  return $self->{impl}->describe_version();
}

sub describe_ring{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  return $self->{impl}->describe_ring($keyspace);
}

sub describe_local_ring{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  return $self->{impl}->describe_local_ring($keyspace);
}

sub describe_token_map{
  my ($self, $request) = @_;

  return $self->{impl}->describe_token_map();
}

sub describe_partitioner{
  my ($self, $request) = @_;

  return $self->{impl}->describe_partitioner();
}

sub describe_snitch{
  my ($self, $request) = @_;

  return $self->{impl}->describe_snitch();
}

sub describe_keyspace{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  return $self->{impl}->describe_keyspace($keyspace);
}

sub describe_splits{
  my ($self, $request) = @_;

  my $cfName = ($request->{'cfName'}) ? $request->{'cfName'} : undef;
  my $start_token = ($request->{'start_token'}) ? $request->{'start_token'} : undef;
  my $end_token = ($request->{'end_token'}) ? $request->{'end_token'} : undef;
  my $keys_per_split = ($request->{'keys_per_split'}) ? $request->{'keys_per_split'} : undef;
  return $self->{impl}->describe_splits($cfName, $start_token, $end_token, $keys_per_split);
}

sub trace_next_query{
  my ($self, $request) = @_;

  return $self->{impl}->trace_next_query();
}

sub describe_splits_ex{
  my ($self, $request) = @_;

  my $cfName = ($request->{'cfName'}) ? $request->{'cfName'} : undef;
  my $start_token = ($request->{'start_token'}) ? $request->{'start_token'} : undef;
  my $end_token = ($request->{'end_token'}) ? $request->{'end_token'} : undef;
  my $keys_per_split = ($request->{'keys_per_split'}) ? $request->{'keys_per_split'} : undef;
  return $self->{impl}->describe_splits_ex($cfName, $start_token, $end_token, $keys_per_split);
}

sub system_add_column_family{
  my ($self, $request) = @_;

  my $cf_def = ($request->{'cf_def'}) ? $request->{'cf_def'} : undef;
  return $self->{impl}->system_add_column_family($cf_def);
}

sub system_drop_column_family{
  my ($self, $request) = @_;

  my $column_family = ($request->{'column_family'}) ? $request->{'column_family'} : undef;
  return $self->{impl}->system_drop_column_family($column_family);
}

sub system_add_keyspace{
  my ($self, $request) = @_;

  my $ks_def = ($request->{'ks_def'}) ? $request->{'ks_def'} : undef;
  return $self->{impl}->system_add_keyspace($ks_def);
}

sub system_drop_keyspace{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  return $self->{impl}->system_drop_keyspace($keyspace);
}

sub system_update_keyspace{
  my ($self, $request) = @_;

  my $ks_def = ($request->{'ks_def'}) ? $request->{'ks_def'} : undef;
  return $self->{impl}->system_update_keyspace($ks_def);
}

sub system_update_column_family{
  my ($self, $request) = @_;

  my $cf_def = ($request->{'cf_def'}) ? $request->{'cf_def'} : undef;
  return $self->{impl}->system_update_column_family($cf_def);
}

sub execute_cql_query{
  my ($self, $request) = @_;

  my $query = ($request->{'query'}) ? $request->{'query'} : undef;
  my $compression = ($request->{'compression'}) ? $request->{'compression'} : undef;
  return $self->{impl}->execute_cql_query($query, $compression);
}

sub execute_cql3_query{
  my ($self, $request) = @_;

  my $query = ($request->{'query'}) ? $request->{'query'} : undef;
  my $compression = ($request->{'compression'}) ? $request->{'compression'} : undef;
  my $consistency = ($request->{'consistency'}) ? $request->{'consistency'} : undef;
  return $self->{impl}->execute_cql3_query($query, $compression, $consistency);
}

sub prepare_cql_query{
  my ($self, $request) = @_;

  my $query = ($request->{'query'}) ? $request->{'query'} : undef;
  my $compression = ($request->{'compression'}) ? $request->{'compression'} : undef;
  return $self->{impl}->prepare_cql_query($query, $compression);
}

sub prepare_cql3_query{
  my ($self, $request) = @_;

  my $query = ($request->{'query'}) ? $request->{'query'} : undef;
  my $compression = ($request->{'compression'}) ? $request->{'compression'} : undef;
  return $self->{impl}->prepare_cql3_query($query, $compression);
}

sub execute_prepared_cql_query{
  my ($self, $request) = @_;

  my $itemId = ($request->{'itemId'}) ? $request->{'itemId'} : undef;
  my $values = ($request->{'values'}) ? $request->{'values'} : undef;
  return $self->{impl}->execute_prepared_cql_query($itemId, $values);
}

sub execute_prepared_cql3_query{
  my ($self, $request) = @_;

  my $itemId = ($request->{'itemId'}) ? $request->{'itemId'} : undef;
  my $values = ($request->{'values'}) ? $request->{'values'} : undef;
  my $consistency = ($request->{'consistency'}) ? $request->{'consistency'} : undef;
  return $self->{impl}->execute_prepared_cql3_query($itemId, $values, $consistency);
}

sub set_cql_version{
  my ($self, $request) = @_;

  my $version = ($request->{'version'}) ? $request->{'version'} : undef;
  return $self->{impl}->set_cql_version($version);
}

package Cassandra::CassandraClient;


use base qw(Cassandra::CassandraIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub login{
  my $self = shift;
  my $auth_request = shift;

    $self->send_login($auth_request);
  $self->recv_login();
}

sub send_login{
  my $self = shift;
  my $auth_request = shift;

  $self->{output}->writeMessageBegin('login', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_login_args->new();
  $args->{auth_request} = $auth_request;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_login{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_login_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{authnx}) {
    die $result->{authnx};
  }
  if (defined $result->{authzx}) {
    die $result->{authzx};
  }
  return;
}
sub set_keyspace{
  my $self = shift;
  my $keyspace = shift;

    $self->send_set_keyspace($keyspace);
  $self->recv_set_keyspace();
}

sub send_set_keyspace{
  my $self = shift;
  my $keyspace = shift;

  $self->{output}->writeMessageBegin('set_keyspace', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_set_keyspace_args->new();
  $args->{keyspace} = $keyspace;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_keyspace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_set_keyspace_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  return;
}
sub get{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $consistency_level = shift;

    $self->send_get($key, $column_path, $consistency_level);
  return $self->recv_get();
}

sub send_get{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_get_args->new();
  $args->{key} = $key;
  $args->{column_path} = $column_path;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_get_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{nfe}) {
    die $result->{nfe};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get failed: unknown result";
}
sub get_slice{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

    $self->send_get_slice($key, $column_parent, $predicate, $consistency_level);
  return $self->recv_get_slice();
}

sub send_get_slice{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_slice', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_get_slice_args->new();
  $args->{key} = $key;
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_slice{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_get_slice_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get_slice failed: unknown result";
}
sub get_count{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

    $self->send_get_count($key, $column_parent, $predicate, $consistency_level);
  return $self->recv_get_count();
}

sub send_get_count{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_count', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_get_count_args->new();
  $args->{key} = $key;
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_count{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_get_count_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get_count failed: unknown result";
}
sub multiget_slice{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

    $self->send_multiget_slice($keys, $column_parent, $predicate, $consistency_level);
  return $self->recv_multiget_slice();
}

sub send_multiget_slice{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('multiget_slice', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_multiget_slice_args->new();
  $args->{keys} = $keys;
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_multiget_slice{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_multiget_slice_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "multiget_slice failed: unknown result";
}
sub multiget_count{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

    $self->send_multiget_count($keys, $column_parent, $predicate, $consistency_level);
  return $self->recv_multiget_count();
}

sub send_multiget_count{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('multiget_count', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_multiget_count_args->new();
  $args->{keys} = $keys;
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_multiget_count{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_multiget_count_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "multiget_count failed: unknown result";
}
sub get_range_slices{
  my $self = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $range = shift;
  my $consistency_level = shift;

    $self->send_get_range_slices($column_parent, $predicate, $range, $consistency_level);
  return $self->recv_get_range_slices();
}

sub send_get_range_slices{
  my $self = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $range = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_range_slices', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_get_range_slices_args->new();
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{range} = $range;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_range_slices{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_get_range_slices_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get_range_slices failed: unknown result";
}
sub get_paged_slice{
  my $self = shift;
  my $column_family = shift;
  my $range = shift;
  my $start_column = shift;
  my $consistency_level = shift;

    $self->send_get_paged_slice($column_family, $range, $start_column, $consistency_level);
  return $self->recv_get_paged_slice();
}

sub send_get_paged_slice{
  my $self = shift;
  my $column_family = shift;
  my $range = shift;
  my $start_column = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_paged_slice', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_get_paged_slice_args->new();
  $args->{column_family} = $column_family;
  $args->{range} = $range;
  $args->{start_column} = $start_column;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_paged_slice{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_get_paged_slice_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get_paged_slice failed: unknown result";
}
sub get_indexed_slices{
  my $self = shift;
  my $column_parent = shift;
  my $index_clause = shift;
  my $column_predicate = shift;
  my $consistency_level = shift;

    $self->send_get_indexed_slices($column_parent, $index_clause, $column_predicate, $consistency_level);
  return $self->recv_get_indexed_slices();
}

sub send_get_indexed_slices{
  my $self = shift;
  my $column_parent = shift;
  my $index_clause = shift;
  my $column_predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_indexed_slices', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_get_indexed_slices_args->new();
  $args->{column_parent} = $column_parent;
  $args->{index_clause} = $index_clause;
  $args->{column_predicate} = $column_predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_indexed_slices{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_get_indexed_slices_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get_indexed_slices failed: unknown result";
}
sub insert{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

    $self->send_insert($key, $column_parent, $column, $consistency_level);
  $self->recv_insert();
}

sub send_insert{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('insert', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_insert_args->new();
  $args->{key} = $key;
  $args->{column_parent} = $column_parent;
  $args->{column} = $column;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_insert{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_insert_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  return;
}
sub add{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

    $self->send_add($key, $column_parent, $column, $consistency_level);
  $self->recv_add();
}

sub send_add{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('add', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_add_args->new();
  $args->{key} = $key;
  $args->{column_parent} = $column_parent;
  $args->{column} = $column;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_add{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_add_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  return;
}
sub cas{
  my $self = shift;
  my $key = shift;
  my $column_family = shift;
  my $expected = shift;
  my $updates = shift;
  my $serial_consistency_level = shift;
  my $commit_consistency_level = shift;

    $self->send_cas($key, $column_family, $expected, $updates, $serial_consistency_level, $commit_consistency_level);
  return $self->recv_cas();
}

sub send_cas{
  my $self = shift;
  my $key = shift;
  my $column_family = shift;
  my $expected = shift;
  my $updates = shift;
  my $serial_consistency_level = shift;
  my $commit_consistency_level = shift;

  $self->{output}->writeMessageBegin('cas', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_cas_args->new();
  $args->{key} = $key;
  $args->{column_family} = $column_family;
  $args->{expected} = $expected;
  $args->{updates} = $updates;
  $args->{serial_consistency_level} = $serial_consistency_level;
  $args->{commit_consistency_level} = $commit_consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_cas{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_cas_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "cas failed: unknown result";
}
sub remove{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

    $self->send_remove($key, $column_path, $timestamp, $consistency_level);
  $self->recv_remove();
}

sub send_remove{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('remove', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_remove_args->new();
  $args->{key} = $key;
  $args->{column_path} = $column_path;
  $args->{timestamp} = $timestamp;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_remove{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_remove_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  return;
}
sub remove_counter{
  my $self = shift;
  my $key = shift;
  my $path = shift;
  my $consistency_level = shift;

    $self->send_remove_counter($key, $path, $consistency_level);
  $self->recv_remove_counter();
}

sub send_remove_counter{
  my $self = shift;
  my $key = shift;
  my $path = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('remove_counter', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_remove_counter_args->new();
  $args->{key} = $key;
  $args->{path} = $path;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_remove_counter{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_remove_counter_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  return;
}
sub batch_mutate{
  my $self = shift;
  my $mutation_map = shift;
  my $consistency_level = shift;

    $self->send_batch_mutate($mutation_map, $consistency_level);
  $self->recv_batch_mutate();
}

sub send_batch_mutate{
  my $self = shift;
  my $mutation_map = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('batch_mutate', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_batch_mutate_args->new();
  $args->{mutation_map} = $mutation_map;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_batch_mutate{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_batch_mutate_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  return;
}
sub atomic_batch_mutate{
  my $self = shift;
  my $mutation_map = shift;
  my $consistency_level = shift;

    $self->send_atomic_batch_mutate($mutation_map, $consistency_level);
  $self->recv_atomic_batch_mutate();
}

sub send_atomic_batch_mutate{
  my $self = shift;
  my $mutation_map = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('atomic_batch_mutate', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_atomic_batch_mutate_args->new();
  $args->{mutation_map} = $mutation_map;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_atomic_batch_mutate{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_atomic_batch_mutate_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  return;
}
sub truncate{
  my $self = shift;
  my $cfname = shift;

    $self->send_truncate($cfname);
  $self->recv_truncate();
}

sub send_truncate{
  my $self = shift;
  my $cfname = shift;

  $self->{output}->writeMessageBegin('truncate', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_truncate_args->new();
  $args->{cfname} = $cfname;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_truncate{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_truncate_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  return;
}
sub get_multi_slice{
  my $self = shift;
  my $request = shift;

    $self->send_get_multi_slice($request);
  return $self->recv_get_multi_slice();
}

sub send_get_multi_slice{
  my $self = shift;
  my $request = shift;

  $self->{output}->writeMessageBegin('get_multi_slice', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_get_multi_slice_args->new();
  $args->{request} = $request;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_multi_slice{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_get_multi_slice_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get_multi_slice failed: unknown result";
}
sub describe_schema_versions{
  my $self = shift;

    $self->send_describe_schema_versions();
  return $self->recv_describe_schema_versions();
}

sub send_describe_schema_versions{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_schema_versions', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_describe_schema_versions_args->new();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_schema_versions{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_describe_schema_versions_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "describe_schema_versions failed: unknown result";
}
sub describe_keyspaces{
  my $self = shift;

    $self->send_describe_keyspaces();
  return $self->recv_describe_keyspaces();
}

sub send_describe_keyspaces{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_keyspaces', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_describe_keyspaces_args->new();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_keyspaces{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_describe_keyspaces_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "describe_keyspaces failed: unknown result";
}
sub describe_cluster_name{
  my $self = shift;

    $self->send_describe_cluster_name();
  return $self->recv_describe_cluster_name();
}

sub send_describe_cluster_name{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_cluster_name', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_describe_cluster_name_args->new();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_cluster_name{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_describe_cluster_name_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "describe_cluster_name failed: unknown result";
}
sub describe_version{
  my $self = shift;

    $self->send_describe_version();
  return $self->recv_describe_version();
}

sub send_describe_version{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_version', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_describe_version_args->new();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_version{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_describe_version_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "describe_version failed: unknown result";
}
sub describe_ring{
  my $self = shift;
  my $keyspace = shift;

    $self->send_describe_ring($keyspace);
  return $self->recv_describe_ring();
}

sub send_describe_ring{
  my $self = shift;
  my $keyspace = shift;

  $self->{output}->writeMessageBegin('describe_ring', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_describe_ring_args->new();
  $args->{keyspace} = $keyspace;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_ring{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_describe_ring_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "describe_ring failed: unknown result";
}
sub describe_local_ring{
  my $self = shift;
  my $keyspace = shift;

    $self->send_describe_local_ring($keyspace);
  return $self->recv_describe_local_ring();
}

sub send_describe_local_ring{
  my $self = shift;
  my $keyspace = shift;

  $self->{output}->writeMessageBegin('describe_local_ring', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_describe_local_ring_args->new();
  $args->{keyspace} = $keyspace;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_local_ring{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_describe_local_ring_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "describe_local_ring failed: unknown result";
}
sub describe_token_map{
  my $self = shift;

    $self->send_describe_token_map();
  return $self->recv_describe_token_map();
}

sub send_describe_token_map{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_token_map', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_describe_token_map_args->new();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_token_map{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_describe_token_map_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "describe_token_map failed: unknown result";
}
sub describe_partitioner{
  my $self = shift;

    $self->send_describe_partitioner();
  return $self->recv_describe_partitioner();
}

sub send_describe_partitioner{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_partitioner', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_describe_partitioner_args->new();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_partitioner{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_describe_partitioner_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "describe_partitioner failed: unknown result";
}
sub describe_snitch{
  my $self = shift;

    $self->send_describe_snitch();
  return $self->recv_describe_snitch();
}

sub send_describe_snitch{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_snitch', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_describe_snitch_args->new();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_snitch{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_describe_snitch_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "describe_snitch failed: unknown result";
}
sub describe_keyspace{
  my $self = shift;
  my $keyspace = shift;

    $self->send_describe_keyspace($keyspace);
  return $self->recv_describe_keyspace();
}

sub send_describe_keyspace{
  my $self = shift;
  my $keyspace = shift;

  $self->{output}->writeMessageBegin('describe_keyspace', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_describe_keyspace_args->new();
  $args->{keyspace} = $keyspace;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_keyspace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_describe_keyspace_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{nfe}) {
    die $result->{nfe};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "describe_keyspace failed: unknown result";
}
sub describe_splits{
  my $self = shift;
  my $cfName = shift;
  my $start_token = shift;
  my $end_token = shift;
  my $keys_per_split = shift;

    $self->send_describe_splits($cfName, $start_token, $end_token, $keys_per_split);
  return $self->recv_describe_splits();
}

sub send_describe_splits{
  my $self = shift;
  my $cfName = shift;
  my $start_token = shift;
  my $end_token = shift;
  my $keys_per_split = shift;

  $self->{output}->writeMessageBegin('describe_splits', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_describe_splits_args->new();
  $args->{cfName} = $cfName;
  $args->{start_token} = $start_token;
  $args->{end_token} = $end_token;
  $args->{keys_per_split} = $keys_per_split;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_splits{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_describe_splits_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "describe_splits failed: unknown result";
}
sub trace_next_query{
  my $self = shift;

    $self->send_trace_next_query();
  return $self->recv_trace_next_query();
}

sub send_trace_next_query{
  my $self = shift;

  $self->{output}->writeMessageBegin('trace_next_query', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_trace_next_query_args->new();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_trace_next_query{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_trace_next_query_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "trace_next_query failed: unknown result";
}
sub describe_splits_ex{
  my $self = shift;
  my $cfName = shift;
  my $start_token = shift;
  my $end_token = shift;
  my $keys_per_split = shift;

    $self->send_describe_splits_ex($cfName, $start_token, $end_token, $keys_per_split);
  return $self->recv_describe_splits_ex();
}

sub send_describe_splits_ex{
  my $self = shift;
  my $cfName = shift;
  my $start_token = shift;
  my $end_token = shift;
  my $keys_per_split = shift;

  $self->{output}->writeMessageBegin('describe_splits_ex', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_describe_splits_ex_args->new();
  $args->{cfName} = $cfName;
  $args->{start_token} = $start_token;
  $args->{end_token} = $end_token;
  $args->{keys_per_split} = $keys_per_split;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_splits_ex{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_describe_splits_ex_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "describe_splits_ex failed: unknown result";
}
sub system_add_column_family{
  my $self = shift;
  my $cf_def = shift;

    $self->send_system_add_column_family($cf_def);
  return $self->recv_system_add_column_family();
}

sub send_system_add_column_family{
  my $self = shift;
  my $cf_def = shift;

  $self->{output}->writeMessageBegin('system_add_column_family', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_system_add_column_family_args->new();
  $args->{cf_def} = $cf_def;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_add_column_family{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_system_add_column_family_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "system_add_column_family failed: unknown result";
}
sub system_drop_column_family{
  my $self = shift;
  my $column_family = shift;

    $self->send_system_drop_column_family($column_family);
  return $self->recv_system_drop_column_family();
}

sub send_system_drop_column_family{
  my $self = shift;
  my $column_family = shift;

  $self->{output}->writeMessageBegin('system_drop_column_family', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_system_drop_column_family_args->new();
  $args->{column_family} = $column_family;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_drop_column_family{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_system_drop_column_family_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "system_drop_column_family failed: unknown result";
}
sub system_add_keyspace{
  my $self = shift;
  my $ks_def = shift;

    $self->send_system_add_keyspace($ks_def);
  return $self->recv_system_add_keyspace();
}

sub send_system_add_keyspace{
  my $self = shift;
  my $ks_def = shift;

  $self->{output}->writeMessageBegin('system_add_keyspace', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_system_add_keyspace_args->new();
  $args->{ks_def} = $ks_def;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_add_keyspace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_system_add_keyspace_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "system_add_keyspace failed: unknown result";
}
sub system_drop_keyspace{
  my $self = shift;
  my $keyspace = shift;

    $self->send_system_drop_keyspace($keyspace);
  return $self->recv_system_drop_keyspace();
}

sub send_system_drop_keyspace{
  my $self = shift;
  my $keyspace = shift;

  $self->{output}->writeMessageBegin('system_drop_keyspace', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_system_drop_keyspace_args->new();
  $args->{keyspace} = $keyspace;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_drop_keyspace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_system_drop_keyspace_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "system_drop_keyspace failed: unknown result";
}
sub system_update_keyspace{
  my $self = shift;
  my $ks_def = shift;

    $self->send_system_update_keyspace($ks_def);
  return $self->recv_system_update_keyspace();
}

sub send_system_update_keyspace{
  my $self = shift;
  my $ks_def = shift;

  $self->{output}->writeMessageBegin('system_update_keyspace', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_system_update_keyspace_args->new();
  $args->{ks_def} = $ks_def;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_update_keyspace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_system_update_keyspace_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "system_update_keyspace failed: unknown result";
}
sub system_update_column_family{
  my $self = shift;
  my $cf_def = shift;

    $self->send_system_update_column_family($cf_def);
  return $self->recv_system_update_column_family();
}

sub send_system_update_column_family{
  my $self = shift;
  my $cf_def = shift;

  $self->{output}->writeMessageBegin('system_update_column_family', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_system_update_column_family_args->new();
  $args->{cf_def} = $cf_def;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_update_column_family{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_system_update_column_family_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "system_update_column_family failed: unknown result";
}
sub execute_cql_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

    $self->send_execute_cql_query($query, $compression);
  return $self->recv_execute_cql_query();
}

sub send_execute_cql_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

  $self->{output}->writeMessageBegin('execute_cql_query', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_execute_cql_query_args->new();
  $args->{query} = $query;
  $args->{compression} = $compression;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_execute_cql_query{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_execute_cql_query_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "execute_cql_query failed: unknown result";
}
sub execute_cql3_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;
  my $consistency = shift;

    $self->send_execute_cql3_query($query, $compression, $consistency);
  return $self->recv_execute_cql3_query();
}

sub send_execute_cql3_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;
  my $consistency = shift;

  $self->{output}->writeMessageBegin('execute_cql3_query', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_execute_cql3_query_args->new();
  $args->{query} = $query;
  $args->{compression} = $compression;
  $args->{consistency} = $consistency;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_execute_cql3_query{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_execute_cql3_query_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "execute_cql3_query failed: unknown result";
}
sub prepare_cql_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

    $self->send_prepare_cql_query($query, $compression);
  return $self->recv_prepare_cql_query();
}

sub send_prepare_cql_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

  $self->{output}->writeMessageBegin('prepare_cql_query', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_prepare_cql_query_args->new();
  $args->{query} = $query;
  $args->{compression} = $compression;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_prepare_cql_query{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_prepare_cql_query_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "prepare_cql_query failed: unknown result";
}
sub prepare_cql3_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

    $self->send_prepare_cql3_query($query, $compression);
  return $self->recv_prepare_cql3_query();
}

sub send_prepare_cql3_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

  $self->{output}->writeMessageBegin('prepare_cql3_query', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_prepare_cql3_query_args->new();
  $args->{query} = $query;
  $args->{compression} = $compression;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_prepare_cql3_query{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_prepare_cql3_query_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "prepare_cql3_query failed: unknown result";
}
sub execute_prepared_cql_query{
  my $self = shift;
  my $itemId = shift;
  my $values = shift;

    $self->send_execute_prepared_cql_query($itemId, $values);
  return $self->recv_execute_prepared_cql_query();
}

sub send_execute_prepared_cql_query{
  my $self = shift;
  my $itemId = shift;
  my $values = shift;

  $self->{output}->writeMessageBegin('execute_prepared_cql_query', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_execute_prepared_cql_query_args->new();
  $args->{itemId} = $itemId;
  $args->{values} = $values;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_execute_prepared_cql_query{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_execute_prepared_cql_query_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "execute_prepared_cql_query failed: unknown result";
}
sub execute_prepared_cql3_query{
  my $self = shift;
  my $itemId = shift;
  my $values = shift;
  my $consistency = shift;

    $self->send_execute_prepared_cql3_query($itemId, $values, $consistency);
  return $self->recv_execute_prepared_cql3_query();
}

sub send_execute_prepared_cql3_query{
  my $self = shift;
  my $itemId = shift;
  my $values = shift;
  my $consistency = shift;

  $self->{output}->writeMessageBegin('execute_prepared_cql3_query', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_execute_prepared_cql3_query_args->new();
  $args->{itemId} = $itemId;
  $args->{values} = $values;
  $args->{consistency} = $consistency;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_execute_prepared_cql3_query{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_execute_prepared_cql3_query_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "execute_prepared_cql3_query failed: unknown result";
}
sub set_cql_version{
  my $self = shift;
  my $version = shift;

    $self->send_set_cql_version($version);
  $self->recv_set_cql_version();
}

sub send_set_cql_version{
  my $self = shift;
  my $version = shift;

  $self->{output}->writeMessageBegin('set_cql_version', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Cassandra::Cassandra_set_cql_version_args->new();
  $args->{version} = $version;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cql_version{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Cassandra::Cassandra_set_cql_version_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  return;
}
package Cassandra::CassandraProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(Thrift::TType::STRUCT);
      $input->readMessageEnd();
      my $x = Thrift::TApplicationException->new('Function '.$fname.' not implemented.', Thrift::TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, Thrift::TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_login {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_login_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_login_result->new();
    eval {
      $self->{handler}->login($args->auth_request);
    }; if( UNIVERSAL::isa($@,'Cassandra::AuthenticationException') ){ 
      $result->{authnx} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::AuthorizationException') ){ 
      $result->{authzx} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('login', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('login', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_keyspace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_set_keyspace_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_set_keyspace_result->new();
    eval {
      $self->{handler}->set_keyspace($args->keyspace);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('set_keyspace', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('set_keyspace', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_get_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_get_result->new();
    eval {
      $result->{success} = $self->{handler}->get($args->key, $args->column_path, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::NotFoundException') ){ 
      $result->{nfe} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_slice {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_get_slice_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_get_slice_result->new();
    eval {
      $result->{success} = $self->{handler}->get_slice($args->key, $args->column_parent, $args->predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get_slice', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get_slice', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_count {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_get_count_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_get_count_result->new();
    eval {
      $result->{success} = $self->{handler}->get_count($args->key, $args->column_parent, $args->predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get_count', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get_count', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_multiget_slice {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_multiget_slice_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_multiget_slice_result->new();
    eval {
      $result->{success} = $self->{handler}->multiget_slice($args->keys, $args->column_parent, $args->predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('multiget_slice', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('multiget_slice', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_multiget_count {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_multiget_count_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_multiget_count_result->new();
    eval {
      $result->{success} = $self->{handler}->multiget_count($args->keys, $args->column_parent, $args->predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('multiget_count', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('multiget_count', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_range_slices {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_get_range_slices_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_get_range_slices_result->new();
    eval {
      $result->{success} = $self->{handler}->get_range_slices($args->column_parent, $args->predicate, $args->range, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get_range_slices', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get_range_slices', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_paged_slice {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_get_paged_slice_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_get_paged_slice_result->new();
    eval {
      $result->{success} = $self->{handler}->get_paged_slice($args->column_family, $args->range, $args->start_column, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get_paged_slice', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get_paged_slice', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_indexed_slices {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_get_indexed_slices_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_get_indexed_slices_result->new();
    eval {
      $result->{success} = $self->{handler}->get_indexed_slices($args->column_parent, $args->index_clause, $args->column_predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get_indexed_slices', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get_indexed_slices', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_insert {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_insert_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_insert_result->new();
    eval {
      $self->{handler}->insert($args->key, $args->column_parent, $args->column, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('insert', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('insert', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_add {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_add_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_add_result->new();
    eval {
      $self->{handler}->add($args->key, $args->column_parent, $args->column, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('add', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('add', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_cas {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_cas_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_cas_result->new();
    eval {
      $result->{success} = $self->{handler}->cas($args->key, $args->column_family, $args->expected, $args->updates, $args->serial_consistency_level, $args->commit_consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('cas', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('cas', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_remove {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_remove_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_remove_result->new();
    eval {
      $self->{handler}->remove($args->key, $args->column_path, $args->timestamp, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('remove', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('remove', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_remove_counter {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_remove_counter_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_remove_counter_result->new();
    eval {
      $self->{handler}->remove_counter($args->key, $args->path, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('remove_counter', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('remove_counter', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_batch_mutate {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_batch_mutate_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_batch_mutate_result->new();
    eval {
      $self->{handler}->batch_mutate($args->mutation_map, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('batch_mutate', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('batch_mutate', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_atomic_batch_mutate {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_atomic_batch_mutate_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_atomic_batch_mutate_result->new();
    eval {
      $self->{handler}->atomic_batch_mutate($args->mutation_map, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('atomic_batch_mutate', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('atomic_batch_mutate', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_truncate {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_truncate_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_truncate_result->new();
    eval {
      $self->{handler}->truncate($args->cfname);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('truncate', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('truncate', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_multi_slice {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_get_multi_slice_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_get_multi_slice_result->new();
    eval {
      $result->{success} = $self->{handler}->get_multi_slice($args->request);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get_multi_slice', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get_multi_slice', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_schema_versions {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_describe_schema_versions_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_describe_schema_versions_result->new();
    eval {
      $result->{success} = $self->{handler}->describe_schema_versions();
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('describe_schema_versions', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('describe_schema_versions', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_keyspaces {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_describe_keyspaces_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_describe_keyspaces_result->new();
    eval {
      $result->{success} = $self->{handler}->describe_keyspaces();
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('describe_keyspaces', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('describe_keyspaces', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_cluster_name {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_describe_cluster_name_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_describe_cluster_name_result->new();
    $result->{success} = $self->{handler}->describe_cluster_name();
    $output->writeMessageBegin('describe_cluster_name', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_version {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_describe_version_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_describe_version_result->new();
    $result->{success} = $self->{handler}->describe_version();
    $output->writeMessageBegin('describe_version', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_ring {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_describe_ring_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_describe_ring_result->new();
    eval {
      $result->{success} = $self->{handler}->describe_ring($args->keyspace);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('describe_ring', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('describe_ring', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_local_ring {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_describe_local_ring_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_describe_local_ring_result->new();
    eval {
      $result->{success} = $self->{handler}->describe_local_ring($args->keyspace);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('describe_local_ring', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('describe_local_ring', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_token_map {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_describe_token_map_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_describe_token_map_result->new();
    eval {
      $result->{success} = $self->{handler}->describe_token_map();
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('describe_token_map', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('describe_token_map', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_partitioner {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_describe_partitioner_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_describe_partitioner_result->new();
    $result->{success} = $self->{handler}->describe_partitioner();
    $output->writeMessageBegin('describe_partitioner', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_snitch {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_describe_snitch_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_describe_snitch_result->new();
    $result->{success} = $self->{handler}->describe_snitch();
    $output->writeMessageBegin('describe_snitch', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_keyspace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_describe_keyspace_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_describe_keyspace_result->new();
    eval {
      $result->{success} = $self->{handler}->describe_keyspace($args->keyspace);
    }; if( UNIVERSAL::isa($@,'Cassandra::NotFoundException') ){ 
      $result->{nfe} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('describe_keyspace', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('describe_keyspace', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_splits {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_describe_splits_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_describe_splits_result->new();
    eval {
      $result->{success} = $self->{handler}->describe_splits($args->cfName, $args->start_token, $args->end_token, $args->keys_per_split);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('describe_splits', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('describe_splits', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_trace_next_query {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_trace_next_query_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_trace_next_query_result->new();
    $result->{success} = $self->{handler}->trace_next_query();
    $output->writeMessageBegin('trace_next_query', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_splits_ex {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_describe_splits_ex_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_describe_splits_ex_result->new();
    eval {
      $result->{success} = $self->{handler}->describe_splits_ex($args->cfName, $args->start_token, $args->end_token, $args->keys_per_split);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('describe_splits_ex', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('describe_splits_ex', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_add_column_family {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_system_add_column_family_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_system_add_column_family_result->new();
    eval {
      $result->{success} = $self->{handler}->system_add_column_family($args->cf_def);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('system_add_column_family', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('system_add_column_family', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_drop_column_family {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_system_drop_column_family_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_system_drop_column_family_result->new();
    eval {
      $result->{success} = $self->{handler}->system_drop_column_family($args->column_family);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('system_drop_column_family', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('system_drop_column_family', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_add_keyspace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_system_add_keyspace_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_system_add_keyspace_result->new();
    eval {
      $result->{success} = $self->{handler}->system_add_keyspace($args->ks_def);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('system_add_keyspace', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('system_add_keyspace', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_drop_keyspace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_system_drop_keyspace_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_system_drop_keyspace_result->new();
    eval {
      $result->{success} = $self->{handler}->system_drop_keyspace($args->keyspace);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('system_drop_keyspace', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('system_drop_keyspace', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_update_keyspace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_system_update_keyspace_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_system_update_keyspace_result->new();
    eval {
      $result->{success} = $self->{handler}->system_update_keyspace($args->ks_def);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('system_update_keyspace', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('system_update_keyspace', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_update_column_family {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_system_update_column_family_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_system_update_column_family_result->new();
    eval {
      $result->{success} = $self->{handler}->system_update_column_family($args->cf_def);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('system_update_column_family', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('system_update_column_family', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_execute_cql_query {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_execute_cql_query_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_execute_cql_query_result->new();
    eval {
      $result->{success} = $self->{handler}->execute_cql_query($args->query, $args->compression);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('execute_cql_query', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('execute_cql_query', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_execute_cql3_query {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_execute_cql3_query_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_execute_cql3_query_result->new();
    eval {
      $result->{success} = $self->{handler}->execute_cql3_query($args->query, $args->compression, $args->consistency);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('execute_cql3_query', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('execute_cql3_query', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_prepare_cql_query {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_prepare_cql_query_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_prepare_cql_query_result->new();
    eval {
      $result->{success} = $self->{handler}->prepare_cql_query($args->query, $args->compression);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('prepare_cql_query', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('prepare_cql_query', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_prepare_cql3_query {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_prepare_cql3_query_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_prepare_cql3_query_result->new();
    eval {
      $result->{success} = $self->{handler}->prepare_cql3_query($args->query, $args->compression);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('prepare_cql3_query', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('prepare_cql3_query', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_execute_prepared_cql_query {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_execute_prepared_cql_query_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_execute_prepared_cql_query_result->new();
    eval {
      $result->{success} = $self->{handler}->execute_prepared_cql_query($args->itemId, $args->values);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('execute_prepared_cql_query', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('execute_prepared_cql_query', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_execute_prepared_cql3_query {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_execute_prepared_cql3_query_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_execute_prepared_cql3_query_result->new();
    eval {
      $result->{success} = $self->{handler}->execute_prepared_cql3_query($args->itemId, $args->values, $args->consistency);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('execute_prepared_cql3_query', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('execute_prepared_cql3_query', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cql_version {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Cassandra::Cassandra_set_cql_version_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Cassandra::Cassandra_set_cql_version_result->new();
    eval {
      $self->{handler}->set_cql_version($args->version);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('set_cql_version', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('set_cql_version', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
