#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
use 5.10.0;
use strict;
use warnings;
use Thrift::Exception;
use Thrift::MessageType;
use Thrift::Type;

package Cassandra::ConsistencyLevel;
use constant ONE => 1;
use constant QUORUM => 2;
use constant LOCAL_QUORUM => 3;
use constant EACH_QUORUM => 4;
use constant ALL => 5;
use constant ANY => 6;
use constant TWO => 7;
use constant THREE => 8;
use constant SERIAL => 9;
use constant LOCAL_SERIAL => 10;
use constant LOCAL_ONE => 11;
package Cassandra::IndexOperator;
use constant EQ => 0;
use constant GTE => 1;
use constant GT => 2;
use constant LTE => 3;
use constant LT => 4;
package Cassandra::IndexType;
use constant KEYS => 0;
use constant CUSTOM => 1;
use constant COMPOSITES => 2;
package Cassandra::Compression;
use constant GZIP => 1;
use constant NONE => 2;
package Cassandra::CqlResultType;
use constant ROWS => 1;
use constant VOID => 2;
use constant INT => 3;

package Cassandra::Column;
use base qw(Class::Accessor);
Cassandra::Column->mk_accessors( qw( name value timestamp ttl ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{value} = undef;
  $self->{timestamp} = undef;
  $self->{ttl} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{ttl}) {
      $self->{ttl} = $vals->{ttl};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Column';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{ttl});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Column');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ttl}) {
    $xfer += $output->writeFieldBegin('ttl', Thrift::TType::I32, 4);
    $xfer += $output->writeI32($self->{ttl});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::SuperColumn;
use base qw(Class::Accessor);
Cassandra::SuperColumn->mk_accessors( qw( name columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SuperColumn';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size0 = 0;
          $self->{columns} = [];
          my $_etype3 = 0;
          $xfer += $input->readListBegin(\$_etype3, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $elem5 = undef;
            $elem5 = Cassandra::Column->new();
            $xfer += $elem5->read($input);
            push(@{$self->{columns}},$elem5);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SuperColumn');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter6 (@{$self->{columns}}) 
        {
          $xfer += ${iter6}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CounterColumn;
use base qw(Class::Accessor);
Cassandra::CounterColumn->mk_accessors( qw( name value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CounterColumn';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CounterColumn');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', Thrift::TType::I64, 2);
    $xfer += $output->writeI64($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CounterSuperColumn;
use base qw(Class::Accessor);
Cassandra::CounterSuperColumn->mk_accessors( qw( name columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CounterSuperColumn';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size7 = 0;
          $self->{columns} = [];
          my $_etype10 = 0;
          $xfer += $input->readListBegin(\$_etype10, \$_size7);
          for (my $_i11 = 0; $_i11 < $_size7; ++$_i11)
          {
            my $elem12 = undef;
            $elem12 = Cassandra::CounterColumn->new();
            $xfer += $elem12->read($input);
            push(@{$self->{columns}},$elem12);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CounterSuperColumn');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter13 (@{$self->{columns}}) 
        {
          $xfer += ${iter13}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::ColumnOrSuperColumn;
use base qw(Class::Accessor);
Cassandra::ColumnOrSuperColumn->mk_accessors( qw( column super_column counter_column counter_super_column ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column} = undef;
  $self->{super_column} = undef;
  $self->{counter_column} = undef;
  $self->{counter_super_column} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{super_column}) {
      $self->{super_column} = $vals->{super_column};
    }
    if (defined $vals->{counter_column}) {
      $self->{counter_column} = $vals->{counter_column};
    }
    if (defined $vals->{counter_super_column}) {
      $self->{counter_super_column} = $vals->{counter_super_column};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnOrSuperColumn';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{column} = Cassandra::Column->new();
        $xfer += $self->{column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{super_column} = Cassandra::SuperColumn->new();
        $xfer += $self->{super_column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{counter_column} = Cassandra::CounterColumn->new();
        $xfer += $self->{counter_column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{counter_super_column} = Cassandra::CounterSuperColumn->new();
        $xfer += $self->{counter_super_column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnOrSuperColumn');
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', Thrift::TType::STRUCT, 1);
    $xfer += $self->{column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{super_column}) {
    $xfer += $output->writeFieldBegin('super_column', Thrift::TType::STRUCT, 2);
    $xfer += $self->{super_column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{counter_column}) {
    $xfer += $output->writeFieldBegin('counter_column', Thrift::TType::STRUCT, 3);
    $xfer += $self->{counter_column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{counter_super_column}) {
    $xfer += $output->writeFieldBegin('counter_super_column', Thrift::TType::STRUCT, 4);
    $xfer += $self->{counter_super_column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::NotFoundException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'NotFoundException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NotFoundException');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::InvalidRequestException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Cassandra::InvalidRequestException->mk_accessors( qw( why ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{why} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{why}) {
      $self->{why} = $vals->{why};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'InvalidRequestException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{why});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('InvalidRequestException');
  if (defined $self->{why}) {
    $xfer += $output->writeFieldBegin('why', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{why});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::UnavailableException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'UnavailableException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UnavailableException');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::TimedOutException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Cassandra::TimedOutException->mk_accessors( qw( acknowledged_by acknowledged_by_batchlog paxos_in_progress ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{acknowledged_by} = undef;
  $self->{acknowledged_by_batchlog} = undef;
  $self->{paxos_in_progress} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{acknowledged_by}) {
      $self->{acknowledged_by} = $vals->{acknowledged_by};
    }
    if (defined $vals->{acknowledged_by_batchlog}) {
      $self->{acknowledged_by_batchlog} = $vals->{acknowledged_by_batchlog};
    }
    if (defined $vals->{paxos_in_progress}) {
      $self->{paxos_in_progress} = $vals->{paxos_in_progress};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TimedOutException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{acknowledged_by});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{acknowledged_by_batchlog});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{paxos_in_progress});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TimedOutException');
  if (defined $self->{acknowledged_by}) {
    $xfer += $output->writeFieldBegin('acknowledged_by', Thrift::TType::I32, 1);
    $xfer += $output->writeI32($self->{acknowledged_by});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{acknowledged_by_batchlog}) {
    $xfer += $output->writeFieldBegin('acknowledged_by_batchlog', Thrift::TType::BOOL, 2);
    $xfer += $output->writeBool($self->{acknowledged_by_batchlog});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{paxos_in_progress}) {
    $xfer += $output->writeFieldBegin('paxos_in_progress', Thrift::TType::BOOL, 3);
    $xfer += $output->writeBool($self->{paxos_in_progress});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::AuthenticationException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Cassandra::AuthenticationException->mk_accessors( qw( why ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{why} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{why}) {
      $self->{why} = $vals->{why};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AuthenticationException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{why});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AuthenticationException');
  if (defined $self->{why}) {
    $xfer += $output->writeFieldBegin('why', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{why});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::AuthorizationException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Cassandra::AuthorizationException->mk_accessors( qw( why ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{why} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{why}) {
      $self->{why} = $vals->{why};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AuthorizationException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{why});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AuthorizationException');
  if (defined $self->{why}) {
    $xfer += $output->writeFieldBegin('why', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{why});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::SchemaDisagreementException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'SchemaDisagreementException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SchemaDisagreementException');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::ColumnParent;
use base qw(Class::Accessor);
Cassandra::ColumnParent->mk_accessors( qw( column_family super_column ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_family} = undef;
  $self->{super_column} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_family}) {
      $self->{column_family} = $vals->{column_family};
    }
    if (defined $vals->{super_column}) {
      $self->{super_column} = $vals->{super_column};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnParent';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{column_family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{super_column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnParent');
  if (defined $self->{column_family}) {
    $xfer += $output->writeFieldBegin('column_family', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{column_family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{super_column}) {
    $xfer += $output->writeFieldBegin('super_column', Thrift::TType::STRING, 4);
    $xfer += $output->writeString($self->{super_column});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::ColumnPath;
use base qw(Class::Accessor);
Cassandra::ColumnPath->mk_accessors( qw( column_family super_column column ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_family} = undef;
  $self->{super_column} = undef;
  $self->{column} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_family}) {
      $self->{column_family} = $vals->{column_family};
    }
    if (defined $vals->{super_column}) {
      $self->{super_column} = $vals->{super_column};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnPath';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{column_family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{super_column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnPath');
  if (defined $self->{column_family}) {
    $xfer += $output->writeFieldBegin('column_family', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{column_family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{super_column}) {
    $xfer += $output->writeFieldBegin('super_column', Thrift::TType::STRING, 4);
    $xfer += $output->writeString($self->{super_column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', Thrift::TType::STRING, 5);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::SliceRange;
use base qw(Class::Accessor);
Cassandra::SliceRange->mk_accessors( qw( start finish reversed count ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{start} = undef;
  $self->{finish} = undef;
  $self->{reversed} = 0;
  $self->{count} = 100;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{start}) {
      $self->{start} = $vals->{start};
    }
    if (defined $vals->{finish}) {
      $self->{finish} = $vals->{finish};
    }
    if (defined $vals->{reversed}) {
      $self->{reversed} = $vals->{reversed};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SliceRange';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{start});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{finish});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{reversed});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SliceRange');
  if (defined $self->{start}) {
    $xfer += $output->writeFieldBegin('start', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{start});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{finish}) {
    $xfer += $output->writeFieldBegin('finish', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{finish});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{reversed}) {
    $xfer += $output->writeFieldBegin('reversed', Thrift::TType::BOOL, 3);
    $xfer += $output->writeBool($self->{reversed});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', Thrift::TType::I32, 4);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::SlicePredicate;
use base qw(Class::Accessor);
Cassandra::SlicePredicate->mk_accessors( qw( column_names slice_range ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_names} = undef;
  $self->{slice_range} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_names}) {
      $self->{column_names} = $vals->{column_names};
    }
    if (defined $vals->{slice_range}) {
      $self->{slice_range} = $vals->{slice_range};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SlicePredicate';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size14 = 0;
          $self->{column_names} = [];
          my $_etype17 = 0;
          $xfer += $input->readListBegin(\$_etype17, \$_size14);
          for (my $_i18 = 0; $_i18 < $_size14; ++$_i18)
          {
            my $elem19 = undef;
            $xfer += $input->readString(\$elem19);
            push(@{$self->{column_names}},$elem19);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{slice_range} = Cassandra::SliceRange->new();
        $xfer += $self->{slice_range}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SlicePredicate');
  if (defined $self->{column_names}) {
    $xfer += $output->writeFieldBegin('column_names', Thrift::TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{column_names}}));
      {
        foreach my $iter20 (@{$self->{column_names}}) 
        {
          $xfer += $output->writeString($iter20);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{slice_range}) {
    $xfer += $output->writeFieldBegin('slice_range', Thrift::TType::STRUCT, 2);
    $xfer += $self->{slice_range}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::IndexExpression;
use base qw(Class::Accessor);
Cassandra::IndexExpression->mk_accessors( qw( column_name op value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_name} = undef;
  $self->{op} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_name}) {
      $self->{column_name} = $vals->{column_name};
    }
    if (defined $vals->{op}) {
      $self->{op} = $vals->{op};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'IndexExpression';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{column_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{op});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('IndexExpression');
  if (defined $self->{column_name}) {
    $xfer += $output->writeFieldBegin('column_name', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{column_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{op}) {
    $xfer += $output->writeFieldBegin('op', Thrift::TType::I32, 2);
    $xfer += $output->writeI32($self->{op});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::IndexClause;
use base qw(Class::Accessor);
Cassandra::IndexClause->mk_accessors( qw( expressions start_key count ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{expressions} = undef;
  $self->{start_key} = undef;
  $self->{count} = 100;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{expressions}) {
      $self->{expressions} = $vals->{expressions};
    }
    if (defined $vals->{start_key}) {
      $self->{start_key} = $vals->{start_key};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'IndexClause';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size21 = 0;
          $self->{expressions} = [];
          my $_etype24 = 0;
          $xfer += $input->readListBegin(\$_etype24, \$_size21);
          for (my $_i25 = 0; $_i25 < $_size21; ++$_i25)
          {
            my $elem26 = undef;
            $elem26 = Cassandra::IndexExpression->new();
            $xfer += $elem26->read($input);
            push(@{$self->{expressions}},$elem26);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{start_key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('IndexClause');
  if (defined $self->{expressions}) {
    $xfer += $output->writeFieldBegin('expressions', Thrift::TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{expressions}}));
      {
        foreach my $iter27 (@{$self->{expressions}}) 
        {
          $xfer += ${iter27}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_key}) {
    $xfer += $output->writeFieldBegin('start_key', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{start_key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', Thrift::TType::I32, 3);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::KeyRange;
use base qw(Class::Accessor);
Cassandra::KeyRange->mk_accessors( qw( start_key end_key start_token end_token row_filter count ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{start_key} = undef;
  $self->{end_key} = undef;
  $self->{start_token} = undef;
  $self->{end_token} = undef;
  $self->{row_filter} = undef;
  $self->{count} = 100;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{start_key}) {
      $self->{start_key} = $vals->{start_key};
    }
    if (defined $vals->{end_key}) {
      $self->{end_key} = $vals->{end_key};
    }
    if (defined $vals->{start_token}) {
      $self->{start_token} = $vals->{start_token};
    }
    if (defined $vals->{end_token}) {
      $self->{end_token} = $vals->{end_token};
    }
    if (defined $vals->{row_filter}) {
      $self->{row_filter} = $vals->{row_filter};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'KeyRange';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{start_key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{end_key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{start_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{end_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size28 = 0;
          $self->{row_filter} = [];
          my $_etype31 = 0;
          $xfer += $input->readListBegin(\$_etype31, \$_size28);
          for (my $_i32 = 0; $_i32 < $_size28; ++$_i32)
          {
            my $elem33 = undef;
            $elem33 = Cassandra::IndexExpression->new();
            $xfer += $elem33->read($input);
            push(@{$self->{row_filter}},$elem33);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('KeyRange');
  if (defined $self->{start_key}) {
    $xfer += $output->writeFieldBegin('start_key', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{start_key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_key}) {
    $xfer += $output->writeFieldBegin('end_key', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{end_key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_token}) {
    $xfer += $output->writeFieldBegin('start_token', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{start_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_token}) {
    $xfer += $output->writeFieldBegin('end_token', Thrift::TType::STRING, 4);
    $xfer += $output->writeString($self->{end_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', Thrift::TType::I32, 5);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row_filter}) {
    $xfer += $output->writeFieldBegin('row_filter', Thrift::TType::LIST, 6);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{row_filter}}));
      {
        foreach my $iter34 (@{$self->{row_filter}}) 
        {
          $xfer += ${iter34}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::KeySlice;
use base qw(Class::Accessor);
Cassandra::KeySlice->mk_accessors( qw( key columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'KeySlice';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size35 = 0;
          $self->{columns} = [];
          my $_etype38 = 0;
          $xfer += $input->readListBegin(\$_etype38, \$_size35);
          for (my $_i39 = 0; $_i39 < $_size35; ++$_i39)
          {
            my $elem40 = undef;
            $elem40 = Cassandra::ColumnOrSuperColumn->new();
            $xfer += $elem40->read($input);
            push(@{$self->{columns}},$elem40);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('KeySlice');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter41 (@{$self->{columns}}) 
        {
          $xfer += ${iter41}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::KeyCount;
use base qw(Class::Accessor);
Cassandra::KeyCount->mk_accessors( qw( key count ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{count} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'KeyCount';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('KeyCount');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', Thrift::TType::I32, 2);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Deletion;
use base qw(Class::Accessor);
Cassandra::Deletion->mk_accessors( qw( timestamp super_column predicate ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{timestamp} = undef;
  $self->{super_column} = undef;
  $self->{predicate} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{super_column}) {
      $self->{super_column} = $vals->{super_column};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Deletion';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{super_column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{predicate} = Cassandra::SlicePredicate->new();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Deletion');
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{super_column}) {
    $xfer += $output->writeFieldBegin('super_column', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{super_column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', Thrift::TType::STRUCT, 3);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Mutation;
use base qw(Class::Accessor);
Cassandra::Mutation->mk_accessors( qw( column_or_supercolumn deletion ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_or_supercolumn} = undef;
  $self->{deletion} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_or_supercolumn}) {
      $self->{column_or_supercolumn} = $vals->{column_or_supercolumn};
    }
    if (defined $vals->{deletion}) {
      $self->{deletion} = $vals->{deletion};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Mutation';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{column_or_supercolumn} = Cassandra::ColumnOrSuperColumn->new();
        $xfer += $self->{column_or_supercolumn}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{deletion} = Cassandra::Deletion->new();
        $xfer += $self->{deletion}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Mutation');
  if (defined $self->{column_or_supercolumn}) {
    $xfer += $output->writeFieldBegin('column_or_supercolumn', Thrift::TType::STRUCT, 1);
    $xfer += $self->{column_or_supercolumn}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deletion}) {
    $xfer += $output->writeFieldBegin('deletion', Thrift::TType::STRUCT, 2);
    $xfer += $self->{deletion}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::EndpointDetails;
use base qw(Class::Accessor);
Cassandra::EndpointDetails->mk_accessors( qw( host datacenter rack ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{host} = undef;
  $self->{datacenter} = undef;
  $self->{rack} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{host}) {
      $self->{host} = $vals->{host};
    }
    if (defined $vals->{datacenter}) {
      $self->{datacenter} = $vals->{datacenter};
    }
    if (defined $vals->{rack}) {
      $self->{rack} = $vals->{rack};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'EndpointDetails';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{host});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{datacenter});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{rack});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('EndpointDetails');
  if (defined $self->{host}) {
    $xfer += $output->writeFieldBegin('host', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{host});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{datacenter}) {
    $xfer += $output->writeFieldBegin('datacenter', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{datacenter});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rack}) {
    $xfer += $output->writeFieldBegin('rack', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{rack});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CASResult;
use base qw(Class::Accessor);
Cassandra::CASResult->mk_accessors( qw( success current_values ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{current_values} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{current_values}) {
      $self->{current_values} = $vals->{current_values};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CASResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size42 = 0;
          $self->{current_values} = [];
          my $_etype45 = 0;
          $xfer += $input->readListBegin(\$_etype45, \$_size42);
          for (my $_i46 = 0; $_i46 < $_size42; ++$_i46)
          {
            my $elem47 = undef;
            $elem47 = Cassandra::Column->new();
            $xfer += $elem47->read($input);
            push(@{$self->{current_values}},$elem47);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CASResult');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::BOOL, 1);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{current_values}) {
    $xfer += $output->writeFieldBegin('current_values', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{current_values}}));
      {
        foreach my $iter48 (@{$self->{current_values}}) 
        {
          $xfer += ${iter48}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::TokenRange;
use base qw(Class::Accessor);
Cassandra::TokenRange->mk_accessors( qw( start_token end_token endpoints rpc_endpoints endpoint_details ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{start_token} = undef;
  $self->{end_token} = undef;
  $self->{endpoints} = undef;
  $self->{rpc_endpoints} = undef;
  $self->{endpoint_details} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{start_token}) {
      $self->{start_token} = $vals->{start_token};
    }
    if (defined $vals->{end_token}) {
      $self->{end_token} = $vals->{end_token};
    }
    if (defined $vals->{endpoints}) {
      $self->{endpoints} = $vals->{endpoints};
    }
    if (defined $vals->{rpc_endpoints}) {
      $self->{rpc_endpoints} = $vals->{rpc_endpoints};
    }
    if (defined $vals->{endpoint_details}) {
      $self->{endpoint_details} = $vals->{endpoint_details};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TokenRange';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{start_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{end_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size49 = 0;
          $self->{endpoints} = [];
          my $_etype52 = 0;
          $xfer += $input->readListBegin(\$_etype52, \$_size49);
          for (my $_i53 = 0; $_i53 < $_size49; ++$_i53)
          {
            my $elem54 = undef;
            $xfer += $input->readString(\$elem54);
            push(@{$self->{endpoints}},$elem54);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size55 = 0;
          $self->{rpc_endpoints} = [];
          my $_etype58 = 0;
          $xfer += $input->readListBegin(\$_etype58, \$_size55);
          for (my $_i59 = 0; $_i59 < $_size55; ++$_i59)
          {
            my $elem60 = undef;
            $xfer += $input->readString(\$elem60);
            push(@{$self->{rpc_endpoints}},$elem60);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size61 = 0;
          $self->{endpoint_details} = [];
          my $_etype64 = 0;
          $xfer += $input->readListBegin(\$_etype64, \$_size61);
          for (my $_i65 = 0; $_i65 < $_size61; ++$_i65)
          {
            my $elem66 = undef;
            $elem66 = Cassandra::EndpointDetails->new();
            $xfer += $elem66->read($input);
            push(@{$self->{endpoint_details}},$elem66);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TokenRange');
  if (defined $self->{start_token}) {
    $xfer += $output->writeFieldBegin('start_token', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{start_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_token}) {
    $xfer += $output->writeFieldBegin('end_token', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{end_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{endpoints}) {
    $xfer += $output->writeFieldBegin('endpoints', Thrift::TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{endpoints}}));
      {
        foreach my $iter67 (@{$self->{endpoints}}) 
        {
          $xfer += $output->writeString($iter67);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rpc_endpoints}) {
    $xfer += $output->writeFieldBegin('rpc_endpoints', Thrift::TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{rpc_endpoints}}));
      {
        foreach my $iter68 (@{$self->{rpc_endpoints}}) 
        {
          $xfer += $output->writeString($iter68);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{endpoint_details}) {
    $xfer += $output->writeFieldBegin('endpoint_details', Thrift::TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{endpoint_details}}));
      {
        foreach my $iter69 (@{$self->{endpoint_details}}) 
        {
          $xfer += ${iter69}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::AuthenticationRequest;
use base qw(Class::Accessor);
Cassandra::AuthenticationRequest->mk_accessors( qw( credentials ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{credentials} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{credentials}) {
      $self->{credentials} = $vals->{credentials};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AuthenticationRequest';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size70 = 0;
          $self->{credentials} = {};
          my $_ktype71 = 0;
          my $_vtype72 = 0;
          $xfer += $input->readMapBegin(\$_ktype71, \$_vtype72, \$_size70);
          for (my $_i74 = 0; $_i74 < $_size70; ++$_i74)
          {
            my $key75 = '';
            my $val76 = '';
            $xfer += $input->readString(\$key75);
            $xfer += $input->readString(\$val76);
            $self->{credentials}->{$key75} = $val76;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AuthenticationRequest');
  if (defined $self->{credentials}) {
    $xfer += $output->writeFieldBegin('credentials', Thrift::TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{credentials}}));
      {
        while( my ($kiter77,$viter78) = each %{$self->{credentials}}) 
        {
          $xfer += $output->writeString($kiter77);
          $xfer += $output->writeString($viter78);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::ColumnDef;
use base qw(Class::Accessor);
Cassandra::ColumnDef->mk_accessors( qw( name validation_class index_type index_name index_options ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{validation_class} = undef;
  $self->{index_type} = undef;
  $self->{index_name} = undef;
  $self->{index_options} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{validation_class}) {
      $self->{validation_class} = $vals->{validation_class};
    }
    if (defined $vals->{index_type}) {
      $self->{index_type} = $vals->{index_type};
    }
    if (defined $vals->{index_name}) {
      $self->{index_name} = $vals->{index_name};
    }
    if (defined $vals->{index_options}) {
      $self->{index_options} = $vals->{index_options};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnDef';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{validation_class});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{index_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{index_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size79 = 0;
          $self->{index_options} = {};
          my $_ktype80 = 0;
          my $_vtype81 = 0;
          $xfer += $input->readMapBegin(\$_ktype80, \$_vtype81, \$_size79);
          for (my $_i83 = 0; $_i83 < $_size79; ++$_i83)
          {
            my $key84 = '';
            my $val85 = '';
            $xfer += $input->readString(\$key84);
            $xfer += $input->readString(\$val85);
            $self->{index_options}->{$key84} = $val85;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnDef');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{validation_class}) {
    $xfer += $output->writeFieldBegin('validation_class', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{validation_class});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{index_type}) {
    $xfer += $output->writeFieldBegin('index_type', Thrift::TType::I32, 3);
    $xfer += $output->writeI32($self->{index_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{index_name}) {
    $xfer += $output->writeFieldBegin('index_name', Thrift::TType::STRING, 4);
    $xfer += $output->writeString($self->{index_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{index_options}) {
    $xfer += $output->writeFieldBegin('index_options', Thrift::TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{index_options}}));
      {
        while( my ($kiter86,$viter87) = each %{$self->{index_options}}) 
        {
          $xfer += $output->writeString($kiter86);
          $xfer += $output->writeString($viter87);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::TriggerDef;
use base qw(Class::Accessor);
Cassandra::TriggerDef->mk_accessors( qw( name options ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{options} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{options}) {
      $self->{options} = $vals->{options};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TriggerDef';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size88 = 0;
          $self->{options} = {};
          my $_ktype89 = 0;
          my $_vtype90 = 0;
          $xfer += $input->readMapBegin(\$_ktype89, \$_vtype90, \$_size88);
          for (my $_i92 = 0; $_i92 < $_size88; ++$_i92)
          {
            my $key93 = '';
            my $val94 = '';
            $xfer += $input->readString(\$key93);
            $xfer += $input->readString(\$val94);
            $self->{options}->{$key93} = $val94;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TriggerDef');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{options}) {
    $xfer += $output->writeFieldBegin('options', Thrift::TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{options}}));
      {
        while( my ($kiter95,$viter96) = each %{$self->{options}}) 
        {
          $xfer += $output->writeString($kiter95);
          $xfer += $output->writeString($viter96);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CfDef;
use base qw(Class::Accessor);
Cassandra::CfDef->mk_accessors( qw( keyspace name column_type comparator_type subcomparator_type comment read_repair_chance column_metadata gc_grace_seconds default_validation_class id min_compaction_threshold max_compaction_threshold key_validation_class key_alias compaction_strategy compaction_strategy_options compression_options bloom_filter_fp_chance caching dclocal_read_repair_chance memtable_flush_period_in_ms default_time_to_live speculative_retry triggers cells_per_row_to_cache min_index_interval max_index_interval row_cache_size key_cache_size row_cache_save_period_in_seconds key_cache_save_period_in_seconds memtable_flush_after_mins memtable_throughput_in_mb memtable_operations_in_millions replicate_on_write merge_shards_chance row_cache_provider row_cache_keys_to_save populate_io_cache_on_flush index_interval ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  $self->{name} = undef;
  $self->{column_type} = "Standard";
  $self->{comparator_type} = "BytesType";
  $self->{subcomparator_type} = undef;
  $self->{comment} = undef;
  $self->{read_repair_chance} = undef;
  $self->{column_metadata} = undef;
  $self->{gc_grace_seconds} = undef;
  $self->{default_validation_class} = undef;
  $self->{id} = undef;
  $self->{min_compaction_threshold} = undef;
  $self->{max_compaction_threshold} = undef;
  $self->{key_validation_class} = undef;
  $self->{key_alias} = undef;
  $self->{compaction_strategy} = undef;
  $self->{compaction_strategy_options} = undef;
  $self->{compression_options} = undef;
  $self->{bloom_filter_fp_chance} = undef;
  $self->{caching} = "keys_only";
  $self->{dclocal_read_repair_chance} = 0;
  $self->{memtable_flush_period_in_ms} = undef;
  $self->{default_time_to_live} = undef;
  $self->{speculative_retry} = "NONE";
  $self->{triggers} = undef;
  $self->{cells_per_row_to_cache} = "100";
  $self->{min_index_interval} = undef;
  $self->{max_index_interval} = undef;
  $self->{row_cache_size} = undef;
  $self->{key_cache_size} = undef;
  $self->{row_cache_save_period_in_seconds} = undef;
  $self->{key_cache_save_period_in_seconds} = undef;
  $self->{memtable_flush_after_mins} = undef;
  $self->{memtable_throughput_in_mb} = undef;
  $self->{memtable_operations_in_millions} = undef;
  $self->{replicate_on_write} = undef;
  $self->{merge_shards_chance} = undef;
  $self->{row_cache_provider} = undef;
  $self->{row_cache_keys_to_save} = undef;
  $self->{populate_io_cache_on_flush} = undef;
  $self->{index_interval} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{column_type}) {
      $self->{column_type} = $vals->{column_type};
    }
    if (defined $vals->{comparator_type}) {
      $self->{comparator_type} = $vals->{comparator_type};
    }
    if (defined $vals->{subcomparator_type}) {
      $self->{subcomparator_type} = $vals->{subcomparator_type};
    }
    if (defined $vals->{comment}) {
      $self->{comment} = $vals->{comment};
    }
    if (defined $vals->{read_repair_chance}) {
      $self->{read_repair_chance} = $vals->{read_repair_chance};
    }
    if (defined $vals->{column_metadata}) {
      $self->{column_metadata} = $vals->{column_metadata};
    }
    if (defined $vals->{gc_grace_seconds}) {
      $self->{gc_grace_seconds} = $vals->{gc_grace_seconds};
    }
    if (defined $vals->{default_validation_class}) {
      $self->{default_validation_class} = $vals->{default_validation_class};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{min_compaction_threshold}) {
      $self->{min_compaction_threshold} = $vals->{min_compaction_threshold};
    }
    if (defined $vals->{max_compaction_threshold}) {
      $self->{max_compaction_threshold} = $vals->{max_compaction_threshold};
    }
    if (defined $vals->{key_validation_class}) {
      $self->{key_validation_class} = $vals->{key_validation_class};
    }
    if (defined $vals->{key_alias}) {
      $self->{key_alias} = $vals->{key_alias};
    }
    if (defined $vals->{compaction_strategy}) {
      $self->{compaction_strategy} = $vals->{compaction_strategy};
    }
    if (defined $vals->{compaction_strategy_options}) {
      $self->{compaction_strategy_options} = $vals->{compaction_strategy_options};
    }
    if (defined $vals->{compression_options}) {
      $self->{compression_options} = $vals->{compression_options};
    }
    if (defined $vals->{bloom_filter_fp_chance}) {
      $self->{bloom_filter_fp_chance} = $vals->{bloom_filter_fp_chance};
    }
    if (defined $vals->{caching}) {
      $self->{caching} = $vals->{caching};
    }
    if (defined $vals->{dclocal_read_repair_chance}) {
      $self->{dclocal_read_repair_chance} = $vals->{dclocal_read_repair_chance};
    }
    if (defined $vals->{memtable_flush_period_in_ms}) {
      $self->{memtable_flush_period_in_ms} = $vals->{memtable_flush_period_in_ms};
    }
    if (defined $vals->{default_time_to_live}) {
      $self->{default_time_to_live} = $vals->{default_time_to_live};
    }
    if (defined $vals->{speculative_retry}) {
      $self->{speculative_retry} = $vals->{speculative_retry};
    }
    if (defined $vals->{triggers}) {
      $self->{triggers} = $vals->{triggers};
    }
    if (defined $vals->{cells_per_row_to_cache}) {
      $self->{cells_per_row_to_cache} = $vals->{cells_per_row_to_cache};
    }
    if (defined $vals->{min_index_interval}) {
      $self->{min_index_interval} = $vals->{min_index_interval};
    }
    if (defined $vals->{max_index_interval}) {
      $self->{max_index_interval} = $vals->{max_index_interval};
    }
    if (defined $vals->{row_cache_size}) {
      $self->{row_cache_size} = $vals->{row_cache_size};
    }
    if (defined $vals->{key_cache_size}) {
      $self->{key_cache_size} = $vals->{key_cache_size};
    }
    if (defined $vals->{row_cache_save_period_in_seconds}) {
      $self->{row_cache_save_period_in_seconds} = $vals->{row_cache_save_period_in_seconds};
    }
    if (defined $vals->{key_cache_save_period_in_seconds}) {
      $self->{key_cache_save_period_in_seconds} = $vals->{key_cache_save_period_in_seconds};
    }
    if (defined $vals->{memtable_flush_after_mins}) {
      $self->{memtable_flush_after_mins} = $vals->{memtable_flush_after_mins};
    }
    if (defined $vals->{memtable_throughput_in_mb}) {
      $self->{memtable_throughput_in_mb} = $vals->{memtable_throughput_in_mb};
    }
    if (defined $vals->{memtable_operations_in_millions}) {
      $self->{memtable_operations_in_millions} = $vals->{memtable_operations_in_millions};
    }
    if (defined $vals->{replicate_on_write}) {
      $self->{replicate_on_write} = $vals->{replicate_on_write};
    }
    if (defined $vals->{merge_shards_chance}) {
      $self->{merge_shards_chance} = $vals->{merge_shards_chance};
    }
    if (defined $vals->{row_cache_provider}) {
      $self->{row_cache_provider} = $vals->{row_cache_provider};
    }
    if (defined $vals->{row_cache_keys_to_save}) {
      $self->{row_cache_keys_to_save} = $vals->{row_cache_keys_to_save};
    }
    if (defined $vals->{populate_io_cache_on_flush}) {
      $self->{populate_io_cache_on_flush} = $vals->{populate_io_cache_on_flush};
    }
    if (defined $vals->{index_interval}) {
      $self->{index_interval} = $vals->{index_interval};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CfDef';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{column_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{comparator_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{subcomparator_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{comment});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == Thrift::TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{read_repair_chance});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size97 = 0;
          $self->{column_metadata} = [];
          my $_etype100 = 0;
          $xfer += $input->readListBegin(\$_etype100, \$_size97);
          for (my $_i101 = 0; $_i101 < $_size97; ++$_i101)
          {
            my $elem102 = undef;
            $elem102 = Cassandra::ColumnDef->new();
            $xfer += $elem102->read($input);
            push(@{$self->{column_metadata}},$elem102);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{gc_grace_seconds});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^15$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{default_validation_class});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^16$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^17$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{min_compaction_threshold});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^18$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{max_compaction_threshold});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^26$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{key_validation_class});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^28$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{key_alias});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^29$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{compaction_strategy});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^30$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size103 = 0;
          $self->{compaction_strategy_options} = {};
          my $_ktype104 = 0;
          my $_vtype105 = 0;
          $xfer += $input->readMapBegin(\$_ktype104, \$_vtype105, \$_size103);
          for (my $_i107 = 0; $_i107 < $_size103; ++$_i107)
          {
            my $key108 = '';
            my $val109 = '';
            $xfer += $input->readString(\$key108);
            $xfer += $input->readString(\$val109);
            $self->{compaction_strategy_options}->{$key108} = $val109;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^32$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size110 = 0;
          $self->{compression_options} = {};
          my $_ktype111 = 0;
          my $_vtype112 = 0;
          $xfer += $input->readMapBegin(\$_ktype111, \$_vtype112, \$_size110);
          for (my $_i114 = 0; $_i114 < $_size110; ++$_i114)
          {
            my $key115 = '';
            my $val116 = '';
            $xfer += $input->readString(\$key115);
            $xfer += $input->readString(\$val116);
            $self->{compression_options}->{$key115} = $val116;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^33$/ && do{      if ($ftype == Thrift::TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{bloom_filter_fp_chance});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^34$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{caching});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^37$/ && do{      if ($ftype == Thrift::TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{dclocal_read_repair_chance});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^39$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{memtable_flush_period_in_ms});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^40$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{default_time_to_live});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^42$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{speculative_retry});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^43$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size117 = 0;
          $self->{triggers} = [];
          my $_etype120 = 0;
          $xfer += $input->readListBegin(\$_etype120, \$_size117);
          for (my $_i121 = 0; $_i121 < $_size117; ++$_i121)
          {
            my $elem122 = undef;
            $elem122 = Cassandra::TriggerDef->new();
            $xfer += $elem122->read($input);
            push(@{$self->{triggers}},$elem122);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^44$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{cells_per_row_to_cache});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^45$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{min_index_interval});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^46$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{max_index_interval});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == Thrift::TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{row_cache_size});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == Thrift::TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{key_cache_size});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^19$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{row_cache_save_period_in_seconds});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^20$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{key_cache_save_period_in_seconds});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^21$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{memtable_flush_after_mins});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^22$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{memtable_throughput_in_mb});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^23$/ && do{      if ($ftype == Thrift::TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{memtable_operations_in_millions});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^24$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{replicate_on_write});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^25$/ && do{      if ($ftype == Thrift::TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{merge_shards_chance});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^27$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{row_cache_provider});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^31$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{row_cache_keys_to_save});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^38$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{populate_io_cache_on_flush});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^41$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{index_interval});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CfDef');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_type}) {
    $xfer += $output->writeFieldBegin('column_type', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{column_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{comparator_type}) {
    $xfer += $output->writeFieldBegin('comparator_type', Thrift::TType::STRING, 5);
    $xfer += $output->writeString($self->{comparator_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{subcomparator_type}) {
    $xfer += $output->writeFieldBegin('subcomparator_type', Thrift::TType::STRING, 6);
    $xfer += $output->writeString($self->{subcomparator_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{comment}) {
    $xfer += $output->writeFieldBegin('comment', Thrift::TType::STRING, 8);
    $xfer += $output->writeString($self->{comment});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row_cache_size}) {
    $xfer += $output->writeFieldBegin('row_cache_size', Thrift::TType::DOUBLE, 9);
    $xfer += $output->writeDouble($self->{row_cache_size});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key_cache_size}) {
    $xfer += $output->writeFieldBegin('key_cache_size', Thrift::TType::DOUBLE, 11);
    $xfer += $output->writeDouble($self->{key_cache_size});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{read_repair_chance}) {
    $xfer += $output->writeFieldBegin('read_repair_chance', Thrift::TType::DOUBLE, 12);
    $xfer += $output->writeDouble($self->{read_repair_chance});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_metadata}) {
    $xfer += $output->writeFieldBegin('column_metadata', Thrift::TType::LIST, 13);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{column_metadata}}));
      {
        foreach my $iter123 (@{$self->{column_metadata}}) 
        {
          $xfer += ${iter123}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{gc_grace_seconds}) {
    $xfer += $output->writeFieldBegin('gc_grace_seconds', Thrift::TType::I32, 14);
    $xfer += $output->writeI32($self->{gc_grace_seconds});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{default_validation_class}) {
    $xfer += $output->writeFieldBegin('default_validation_class', Thrift::TType::STRING, 15);
    $xfer += $output->writeString($self->{default_validation_class});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', Thrift::TType::I32, 16);
    $xfer += $output->writeI32($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{min_compaction_threshold}) {
    $xfer += $output->writeFieldBegin('min_compaction_threshold', Thrift::TType::I32, 17);
    $xfer += $output->writeI32($self->{min_compaction_threshold});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_compaction_threshold}) {
    $xfer += $output->writeFieldBegin('max_compaction_threshold', Thrift::TType::I32, 18);
    $xfer += $output->writeI32($self->{max_compaction_threshold});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row_cache_save_period_in_seconds}) {
    $xfer += $output->writeFieldBegin('row_cache_save_period_in_seconds', Thrift::TType::I32, 19);
    $xfer += $output->writeI32($self->{row_cache_save_period_in_seconds});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key_cache_save_period_in_seconds}) {
    $xfer += $output->writeFieldBegin('key_cache_save_period_in_seconds', Thrift::TType::I32, 20);
    $xfer += $output->writeI32($self->{key_cache_save_period_in_seconds});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{memtable_flush_after_mins}) {
    $xfer += $output->writeFieldBegin('memtable_flush_after_mins', Thrift::TType::I32, 21);
    $xfer += $output->writeI32($self->{memtable_flush_after_mins});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{memtable_throughput_in_mb}) {
    $xfer += $output->writeFieldBegin('memtable_throughput_in_mb', Thrift::TType::I32, 22);
    $xfer += $output->writeI32($self->{memtable_throughput_in_mb});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{memtable_operations_in_millions}) {
    $xfer += $output->writeFieldBegin('memtable_operations_in_millions', Thrift::TType::DOUBLE, 23);
    $xfer += $output->writeDouble($self->{memtable_operations_in_millions});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{replicate_on_write}) {
    $xfer += $output->writeFieldBegin('replicate_on_write', Thrift::TType::BOOL, 24);
    $xfer += $output->writeBool($self->{replicate_on_write});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{merge_shards_chance}) {
    $xfer += $output->writeFieldBegin('merge_shards_chance', Thrift::TType::DOUBLE, 25);
    $xfer += $output->writeDouble($self->{merge_shards_chance});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key_validation_class}) {
    $xfer += $output->writeFieldBegin('key_validation_class', Thrift::TType::STRING, 26);
    $xfer += $output->writeString($self->{key_validation_class});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row_cache_provider}) {
    $xfer += $output->writeFieldBegin('row_cache_provider', Thrift::TType::STRING, 27);
    $xfer += $output->writeString($self->{row_cache_provider});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key_alias}) {
    $xfer += $output->writeFieldBegin('key_alias', Thrift::TType::STRING, 28);
    $xfer += $output->writeString($self->{key_alias});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compaction_strategy}) {
    $xfer += $output->writeFieldBegin('compaction_strategy', Thrift::TType::STRING, 29);
    $xfer += $output->writeString($self->{compaction_strategy});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compaction_strategy_options}) {
    $xfer += $output->writeFieldBegin('compaction_strategy_options', Thrift::TType::MAP, 30);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{compaction_strategy_options}}));
      {
        while( my ($kiter124,$viter125) = each %{$self->{compaction_strategy_options}}) 
        {
          $xfer += $output->writeString($kiter124);
          $xfer += $output->writeString($viter125);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row_cache_keys_to_save}) {
    $xfer += $output->writeFieldBegin('row_cache_keys_to_save', Thrift::TType::I32, 31);
    $xfer += $output->writeI32($self->{row_cache_keys_to_save});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compression_options}) {
    $xfer += $output->writeFieldBegin('compression_options', Thrift::TType::MAP, 32);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{compression_options}}));
      {
        while( my ($kiter126,$viter127) = each %{$self->{compression_options}}) 
        {
          $xfer += $output->writeString($kiter126);
          $xfer += $output->writeString($viter127);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{bloom_filter_fp_chance}) {
    $xfer += $output->writeFieldBegin('bloom_filter_fp_chance', Thrift::TType::DOUBLE, 33);
    $xfer += $output->writeDouble($self->{bloom_filter_fp_chance});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{caching}) {
    $xfer += $output->writeFieldBegin('caching', Thrift::TType::STRING, 34);
    $xfer += $output->writeString($self->{caching});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{dclocal_read_repair_chance}) {
    $xfer += $output->writeFieldBegin('dclocal_read_repair_chance', Thrift::TType::DOUBLE, 37);
    $xfer += $output->writeDouble($self->{dclocal_read_repair_chance});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{populate_io_cache_on_flush}) {
    $xfer += $output->writeFieldBegin('populate_io_cache_on_flush', Thrift::TType::BOOL, 38);
    $xfer += $output->writeBool($self->{populate_io_cache_on_flush});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{memtable_flush_period_in_ms}) {
    $xfer += $output->writeFieldBegin('memtable_flush_period_in_ms', Thrift::TType::I32, 39);
    $xfer += $output->writeI32($self->{memtable_flush_period_in_ms});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{default_time_to_live}) {
    $xfer += $output->writeFieldBegin('default_time_to_live', Thrift::TType::I32, 40);
    $xfer += $output->writeI32($self->{default_time_to_live});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{index_interval}) {
    $xfer += $output->writeFieldBegin('index_interval', Thrift::TType::I32, 41);
    $xfer += $output->writeI32($self->{index_interval});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{speculative_retry}) {
    $xfer += $output->writeFieldBegin('speculative_retry', Thrift::TType::STRING, 42);
    $xfer += $output->writeString($self->{speculative_retry});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{triggers}) {
    $xfer += $output->writeFieldBegin('triggers', Thrift::TType::LIST, 43);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{triggers}}));
      {
        foreach my $iter128 (@{$self->{triggers}}) 
        {
          $xfer += ${iter128}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells_per_row_to_cache}) {
    $xfer += $output->writeFieldBegin('cells_per_row_to_cache', Thrift::TType::STRING, 44);
    $xfer += $output->writeString($self->{cells_per_row_to_cache});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{min_index_interval}) {
    $xfer += $output->writeFieldBegin('min_index_interval', Thrift::TType::I32, 45);
    $xfer += $output->writeI32($self->{min_index_interval});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_index_interval}) {
    $xfer += $output->writeFieldBegin('max_index_interval', Thrift::TType::I32, 46);
    $xfer += $output->writeI32($self->{max_index_interval});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::KsDef;
use base qw(Class::Accessor);
Cassandra::KsDef->mk_accessors( qw( name strategy_class strategy_options replication_factor cf_defs durable_writes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{strategy_class} = undef;
  $self->{strategy_options} = undef;
  $self->{replication_factor} = undef;
  $self->{cf_defs} = undef;
  $self->{durable_writes} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{strategy_class}) {
      $self->{strategy_class} = $vals->{strategy_class};
    }
    if (defined $vals->{strategy_options}) {
      $self->{strategy_options} = $vals->{strategy_options};
    }
    if (defined $vals->{replication_factor}) {
      $self->{replication_factor} = $vals->{replication_factor};
    }
    if (defined $vals->{cf_defs}) {
      $self->{cf_defs} = $vals->{cf_defs};
    }
    if (defined $vals->{durable_writes}) {
      $self->{durable_writes} = $vals->{durable_writes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'KsDef';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{strategy_class});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size129 = 0;
          $self->{strategy_options} = {};
          my $_ktype130 = 0;
          my $_vtype131 = 0;
          $xfer += $input->readMapBegin(\$_ktype130, \$_vtype131, \$_size129);
          for (my $_i133 = 0; $_i133 < $_size129; ++$_i133)
          {
            my $key134 = '';
            my $val135 = '';
            $xfer += $input->readString(\$key134);
            $xfer += $input->readString(\$val135);
            $self->{strategy_options}->{$key134} = $val135;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{replication_factor});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size136 = 0;
          $self->{cf_defs} = [];
          my $_etype139 = 0;
          $xfer += $input->readListBegin(\$_etype139, \$_size136);
          for (my $_i140 = 0; $_i140 < $_size136; ++$_i140)
          {
            my $elem141 = undef;
            $elem141 = Cassandra::CfDef->new();
            $xfer += $elem141->read($input);
            push(@{$self->{cf_defs}},$elem141);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{durable_writes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('KsDef');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{strategy_class}) {
    $xfer += $output->writeFieldBegin('strategy_class', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{strategy_class});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{strategy_options}) {
    $xfer += $output->writeFieldBegin('strategy_options', Thrift::TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{strategy_options}}));
      {
        while( my ($kiter142,$viter143) = each %{$self->{strategy_options}}) 
        {
          $xfer += $output->writeString($kiter142);
          $xfer += $output->writeString($viter143);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{replication_factor}) {
    $xfer += $output->writeFieldBegin('replication_factor', Thrift::TType::I32, 4);
    $xfer += $output->writeI32($self->{replication_factor});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cf_defs}) {
    $xfer += $output->writeFieldBegin('cf_defs', Thrift::TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{cf_defs}}));
      {
        foreach my $iter144 (@{$self->{cf_defs}}) 
        {
          $xfer += ${iter144}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{durable_writes}) {
    $xfer += $output->writeFieldBegin('durable_writes', Thrift::TType::BOOL, 6);
    $xfer += $output->writeBool($self->{durable_writes});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CqlRow;
use base qw(Class::Accessor);
Cassandra::CqlRow->mk_accessors( qw( key columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CqlRow';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size145 = 0;
          $self->{columns} = [];
          my $_etype148 = 0;
          $xfer += $input->readListBegin(\$_etype148, \$_size145);
          for (my $_i149 = 0; $_i149 < $_size145; ++$_i149)
          {
            my $elem150 = undef;
            $elem150 = Cassandra::Column->new();
            $xfer += $elem150->read($input);
            push(@{$self->{columns}},$elem150);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CqlRow');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter151 (@{$self->{columns}}) 
        {
          $xfer += ${iter151}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CqlMetadata;
use base qw(Class::Accessor);
Cassandra::CqlMetadata->mk_accessors( qw( name_types value_types default_name_type default_value_type ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name_types} = undef;
  $self->{value_types} = undef;
  $self->{default_name_type} = undef;
  $self->{default_value_type} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name_types}) {
      $self->{name_types} = $vals->{name_types};
    }
    if (defined $vals->{value_types}) {
      $self->{value_types} = $vals->{value_types};
    }
    if (defined $vals->{default_name_type}) {
      $self->{default_name_type} = $vals->{default_name_type};
    }
    if (defined $vals->{default_value_type}) {
      $self->{default_value_type} = $vals->{default_value_type};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CqlMetadata';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size152 = 0;
          $self->{name_types} = {};
          my $_ktype153 = 0;
          my $_vtype154 = 0;
          $xfer += $input->readMapBegin(\$_ktype153, \$_vtype154, \$_size152);
          for (my $_i156 = 0; $_i156 < $_size152; ++$_i156)
          {
            my $key157 = '';
            my $val158 = '';
            $xfer += $input->readString(\$key157);
            $xfer += $input->readString(\$val158);
            $self->{name_types}->{$key157} = $val158;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size159 = 0;
          $self->{value_types} = {};
          my $_ktype160 = 0;
          my $_vtype161 = 0;
          $xfer += $input->readMapBegin(\$_ktype160, \$_vtype161, \$_size159);
          for (my $_i163 = 0; $_i163 < $_size159; ++$_i163)
          {
            my $key164 = '';
            my $val165 = '';
            $xfer += $input->readString(\$key164);
            $xfer += $input->readString(\$val165);
            $self->{value_types}->{$key164} = $val165;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{default_name_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{default_value_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CqlMetadata');
  if (defined $self->{name_types}) {
    $xfer += $output->writeFieldBegin('name_types', Thrift::TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{name_types}}));
      {
        while( my ($kiter166,$viter167) = each %{$self->{name_types}}) 
        {
          $xfer += $output->writeString($kiter166);
          $xfer += $output->writeString($viter167);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value_types}) {
    $xfer += $output->writeFieldBegin('value_types', Thrift::TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{value_types}}));
      {
        while( my ($kiter168,$viter169) = each %{$self->{value_types}}) 
        {
          $xfer += $output->writeString($kiter168);
          $xfer += $output->writeString($viter169);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{default_name_type}) {
    $xfer += $output->writeFieldBegin('default_name_type', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{default_name_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{default_value_type}) {
    $xfer += $output->writeFieldBegin('default_value_type', Thrift::TType::STRING, 4);
    $xfer += $output->writeString($self->{default_value_type});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CqlResult;
use base qw(Class::Accessor);
Cassandra::CqlResult->mk_accessors( qw( type rows num schema ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{type} = undef;
  $self->{rows} = undef;
  $self->{num} = undef;
  $self->{schema} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
    if (defined $vals->{rows}) {
      $self->{rows} = $vals->{rows};
    }
    if (defined $vals->{num}) {
      $self->{num} = $vals->{num};
    }
    if (defined $vals->{schema}) {
      $self->{schema} = $vals->{schema};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CqlResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size170 = 0;
          $self->{rows} = [];
          my $_etype173 = 0;
          $xfer += $input->readListBegin(\$_etype173, \$_size170);
          for (my $_i174 = 0; $_i174 < $_size170; ++$_i174)
          {
            my $elem175 = undef;
            $elem175 = Cassandra::CqlRow->new();
            $xfer += $elem175->read($input);
            push(@{$self->{rows}},$elem175);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{num});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{schema} = Cassandra::CqlMetadata->new();
        $xfer += $self->{schema}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CqlResult');
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', Thrift::TType::I32, 1);
    $xfer += $output->writeI32($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rows}) {
    $xfer += $output->writeFieldBegin('rows', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{rows}}));
      {
        foreach my $iter176 (@{$self->{rows}}) 
        {
          $xfer += ${iter176}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{num}) {
    $xfer += $output->writeFieldBegin('num', Thrift::TType::I32, 3);
    $xfer += $output->writeI32($self->{num});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{schema}) {
    $xfer += $output->writeFieldBegin('schema', Thrift::TType::STRUCT, 4);
    $xfer += $self->{schema}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CqlPreparedResult;
use base qw(Class::Accessor);
Cassandra::CqlPreparedResult->mk_accessors( qw( itemId count variable_types variable_names ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{itemId} = undef;
  $self->{count} = undef;
  $self->{variable_types} = undef;
  $self->{variable_names} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{itemId}) {
      $self->{itemId} = $vals->{itemId};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
    if (defined $vals->{variable_types}) {
      $self->{variable_types} = $vals->{variable_types};
    }
    if (defined $vals->{variable_names}) {
      $self->{variable_names} = $vals->{variable_names};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CqlPreparedResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{itemId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size177 = 0;
          $self->{variable_types} = [];
          my $_etype180 = 0;
          $xfer += $input->readListBegin(\$_etype180, \$_size177);
          for (my $_i181 = 0; $_i181 < $_size177; ++$_i181)
          {
            my $elem182 = undef;
            $xfer += $input->readString(\$elem182);
            push(@{$self->{variable_types}},$elem182);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size183 = 0;
          $self->{variable_names} = [];
          my $_etype186 = 0;
          $xfer += $input->readListBegin(\$_etype186, \$_size183);
          for (my $_i187 = 0; $_i187 < $_size183; ++$_i187)
          {
            my $elem188 = undef;
            $xfer += $input->readString(\$elem188);
            push(@{$self->{variable_names}},$elem188);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CqlPreparedResult');
  if (defined $self->{itemId}) {
    $xfer += $output->writeFieldBegin('itemId', Thrift::TType::I32, 1);
    $xfer += $output->writeI32($self->{itemId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', Thrift::TType::I32, 2);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{variable_types}) {
    $xfer += $output->writeFieldBegin('variable_types', Thrift::TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{variable_types}}));
      {
        foreach my $iter189 (@{$self->{variable_types}}) 
        {
          $xfer += $output->writeString($iter189);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{variable_names}) {
    $xfer += $output->writeFieldBegin('variable_names', Thrift::TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{variable_names}}));
      {
        foreach my $iter190 (@{$self->{variable_names}}) 
        {
          $xfer += $output->writeString($iter190);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CfSplit;
use base qw(Class::Accessor);
Cassandra::CfSplit->mk_accessors( qw( start_token end_token row_count ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{start_token} = undef;
  $self->{end_token} = undef;
  $self->{row_count} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{start_token}) {
      $self->{start_token} = $vals->{start_token};
    }
    if (defined $vals->{end_token}) {
      $self->{end_token} = $vals->{end_token};
    }
    if (defined $vals->{row_count}) {
      $self->{row_count} = $vals->{row_count};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CfSplit';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{start_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{end_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{row_count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CfSplit');
  if (defined $self->{start_token}) {
    $xfer += $output->writeFieldBegin('start_token', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{start_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_token}) {
    $xfer += $output->writeFieldBegin('end_token', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{end_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row_count}) {
    $xfer += $output->writeFieldBegin('row_count', Thrift::TType::I64, 3);
    $xfer += $output->writeI64($self->{row_count});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::ColumnSlice;
use base qw(Class::Accessor);
Cassandra::ColumnSlice->mk_accessors( qw( start finish ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{start} = undef;
  $self->{finish} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{start}) {
      $self->{start} = $vals->{start};
    }
    if (defined $vals->{finish}) {
      $self->{finish} = $vals->{finish};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnSlice';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{start});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{finish});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnSlice');
  if (defined $self->{start}) {
    $xfer += $output->writeFieldBegin('start', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{start});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{finish}) {
    $xfer += $output->writeFieldBegin('finish', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{finish});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::MultiSliceRequest;
use base qw(Class::Accessor);
Cassandra::MultiSliceRequest->mk_accessors( qw( key column_parent column_slices reversed count consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_parent} = undef;
  $self->{column_slices} = undef;
  $self->{reversed} = 0;
  $self->{count} = 1000;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{column_slices}) {
      $self->{column_slices} = $vals->{column_slices};
    }
    if (defined $vals->{reversed}) {
      $self->{reversed} = $vals->{reversed};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'MultiSliceRequest';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{column_parent} = Cassandra::ColumnParent->new();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size191 = 0;
          $self->{column_slices} = [];
          my $_etype194 = 0;
          $xfer += $input->readListBegin(\$_etype194, \$_size191);
          for (my $_i195 = 0; $_i195 < $_size191; ++$_i195)
          {
            my $elem196 = undef;
            $elem196 = Cassandra::ColumnSlice->new();
            $xfer += $elem196->read($input);
            push(@{$self->{column_slices}},$elem196);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{reversed});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('MultiSliceRequest');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', Thrift::TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_slices}) {
    $xfer += $output->writeFieldBegin('column_slices', Thrift::TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{column_slices}}));
      {
        foreach my $iter197 (@{$self->{column_slices}}) 
        {
          $xfer += ${iter197}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{reversed}) {
    $xfer += $output->writeFieldBegin('reversed', Thrift::TType::BOOL, 4);
    $xfer += $output->writeBool($self->{reversed});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', Thrift::TType::I32, 5);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Thrift::TType::I32, 6);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;
